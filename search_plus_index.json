{"./":{"url":"./","title":"Introduction","keywords":"","body":"hazel-learnbook 🌈 Introduction My personal front-end learning record 🔗 Powered by Gitbook # install $ npm install -g gitbook-cli # usage with nvm ✨ Gitbook Features GitBook GitBook Plugins generate a SUMMARY.MD via Gitbook Summary Automated deployment via Github Actions choose /docs via Github Pages Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:22:02 "},"前端工具/fetch.html":{"url":"前端工具/fetch.html","title":"Fetch","keywords":"","body":"fetch features fetch() 的功能与 XMLHttpRequest 基本相同，但有三个主要的差异 promise 模块化设计，API 分散在多个对象上（Response、Request、Headers） 数据流（stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内容占用；XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来 请求是否成功标识（只有网络错误，或者无法连接时，fetch() 才会报错，其他情况都不会报错，而是认为请求成功） 捕获错误 try catch 模块化对象 Response 对象 fetch() 请求成功以后，得到的是一个 Response 对象，response 是一个 Stream 对象。 const response = await fetch(url) // 同步属性 console.log('response.ok', response.ok) // 返回一个布尔值，表示请求是否成功，true对应 HTTP 请求的状态码 200 到 299，false对应其他的状态码 console.log('response.status', response.status) // 回一个数字，表示 HTTP 回应的状态码 console.log('response.statusText', response.statusText) // 返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回\"OK\"） console.log('response.url', response.url) // 返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL console.log('response.type', response.type) // 返回请求的类型 console.log('response.redirected', response.redirected) // 返回一个布尔值，表示请求是否发生过跳转 // 异步方法 // Response对象根据服务器返回的不同类型的数据，提供了不同的读取方法。 await response.text() // 得到文本字符串，比如 HTML 文件。 await response.json() // 得到 JSON 对象。 await response.blob() // 得到二进制 Blob 对象，比如图片文件。 await response.formData() // 得到 FormData 表单对象，主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。 await response.arrayBuffer() // 得到二进制 ArrayBuffer 对象，比如音频文件。 // Stream 对象只能读取一次，读取完就没了，再读取会报错，可以通过创建Response对象的副本，实现多次读取。 const response2 = response.clone() Headers 对象 Response 对象还有一个 Response.headers 属性，指向一个 Headers 对象，对应 HTTP 回应的所有标头。 const headers = response.headers Headers.get() // 根据指定的键名，返回键值。 Headers.has() // 返回一个布尔值，表示是否包含某个标头。 Headers.set() // 将指定的键名设置为新的键值，如果该键名不存在则会添加。 Headers.append() // 添加标头。 Headers.delete() // 删除标头。 Headers.keys() // 返回一个遍历器，可以依次遍历所有键名。 Headers.values() // 返回一个遍历器，可以依次遍历所有键值。 Headers.entries() // 返回一个遍历器，可以依次遍历所有键值对（[key, value]）。 Headers.forEach() // 依次遍历标头，每个标头都会执行一次参数函数。 ReadableStream 对象 Response 对象有一个 Response.body.getReader() 属性，指向一个 ReadableStream 对象，可以用来分块读取内容，应用之一就是显示下载的进度 const response = await fetch('flower.jpg') const reader = response.body.getReader() // 返回一个遍历器。这个遍历器的read()方法每次返回一个对象，表示本次读取的内容块。 while(true) { // done属性是一个布尔值，用来判断有没有读完；value属性是一个 arrayBuffer 数组，表示内容块的内容，而value.length属性是当前块的大小。 const {done, value} = await reader.read() if (done) { break } console.log(`Received ${value.length} bytes`) } AbortController 对象 取消 fetch() 请求需要使用 AbortController 对象 // const controller = new AbortController() const signal = controller.signal const postreq = await fetch(getContentByTypeCodeUrl, { method: 'post', headers: { 'Content-Type': 'application/json;charset=utf-8' }, body: JSON.stringify({ platformSource: 0, typeCode: 'orderMust' }) signal: signal // 指定一个 AbortSignal 实例，用于取消fetch()请求 }) signal.addEventListener('abort', (e) => { console.log('abort', e) }) // 用于取消 fetch 请求 setTimeout(() => { controller.abort() }, 2000) 请求数据类型 let params = {} const response = await fetch('xxx', { method: 'POST', body: params }) 提交 JSON 数据 params = JSON.stringify(user) 提交表单 const form = document.querySelector('form') params = new FormData(form) 文件上传 const input = document.querySelector('input[type=\"file\"]') const data = new FormData() data.append('file', input.files[0]) data.append('user', 'foo') params = data 直接上传二进制数据 let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png') ) params = blob get 请求的参数转对象传递 直接传：❎ Failed to execute 'fetch' on 'Window': Request with GET/HEAD method cannot have body 借助 Qs：✅ const params = { path: url, color: 128, level: 9 } fetch(`/sharp-compress-gif/compression?${Qs.stringify(params)}`, { method: 'GET', }) usage Fetch API 教程 try { /** GET 请求 */ // fetch() 接收到的 response 是一个 Stream 对象 const response = await fetch(queryCouponConfigListUrl) const resData = await response.json() /** POST 请求 */ const postreq = await fetch(getContentByTypeCodeUrl, { method: 'post', headers: { 'Content-Type': 'application/json;charset=utf-8' }, body: JSON.stringify({ platformSource: 0, typeCode: 'orderMust' }), referrer: 'about:client', referrerPolicy: 'no-referrer-when-downgrade', mode: 'cors', // 允许跨域请求 credentials: 'same-origin', // 同源请求时发送 Cookie，跨域请求时不发送 cache: 'default', // 先在缓存里面寻找匹配的请求 redirect: 'follow', // fetch()跟随 HTTP 跳转 integrity: '', // 指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。 keepalive: true, // 该属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据 signal: signal // 指定一个 AbortSignal 实例，用于取消fetch()请求 }) const postresult = await postreq.json() console.log('result', postresult) } catch (e) { console.log('error', e) } Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:34:08 "},"前端工具/html2canvas.html":{"url":"前端工具/html2canvas.html","title":"Html 2 Canvas","keywords":"","body":"html2canvas 读取已经渲染好的 DOM 元素的结构和样式信息，然后基于这些信息去构建截图，呈现在 canvas 画布中。 使用场景 生成 canvas 下载图片 页面截图打印 安装 npm i html2canvas 使用 ... 下载 import html2canvas from 'html2canvas' download() { html2canvas(document.querySelector('#banner'), { useCORS: true, // 是否尝试使用CORS从服务器加载图像 allowTaint: false, // 是否允许跨域图像污染画布 scale: 4, // 放大倍数 提高图片质量 width: dom.offsetWidth, // 直接取得需要转为图片的dom元素的宽高 height: dom.offsetHeight, }).then(canvas => { // 去除锯齿 let context = canvas.getContext('2d') context.mozImageSmoothingEnabled = false context.webkitImageSmoothingEnabled = false context.msImageSmoothingEnabled = false context.imageSmoothingEnabled = false // 加载动画 this.posterLoading = Loading.service({ lock: true, text: '下载海报中……', background: 'rgba(0, 0, 0, 0.5)', }) let self = this let url = canvas.toDataURL() let xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.responseType = 'blob' xhr.onload = function () { if (this.status === 200) { let blob = this.response let fileName = self.posterTitle.includes('.') ? self.posterTitle + '.png' : self.posterTitle if (navigator.msSaveBlob == null) { const link = document.createElement('a') const event = new MouseEvent('click') link.download = fileName link.href = URL.createObjectURL(blob) link.dispatchEvent(event) } else { navigator.msSaveBlob(blob, fileName) } } setTimeout(() => { self.posterLoading.close() }, 200) } xhr.send() // 模拟下载 const link = document.createElement('a') const event = new MouseEvent('click') link.download = this.activityTitle link.href = canvas.toDataURL() link.dispatchEvent(event) }) }, 分辨率 scale： scalewindow.devicePixelRatio 用于渲染的缩放比例，默认为浏览器设备像素比 问题 图片不显示 可能原因： html2canvas 没有配置 useCORS: true // 是否尝试使用 CORS 从服务器加载图像 后台没有配置跨域 后台配置跨域了但控制台还是显示跨域错误 原因： 浏览器本地缓存错误，即重复请求了相同的接口，导致跨域错误。 因为 html2canvas 只会根据 dom 结果请求并且对图片来源有限制。当 dom 有图片就会请求网络，所以 canvas 第二次请求实际上是从缓存获取，如果从缓存读取类似本地读取照片则会有跨域限制。 验证： 开启控制台网络的禁止缓存选项 解决： 加 cdn，但要加钱 配置 CORS 规则，附加相关 Header，选中返回 vary: origin 头以避免本地缓存错乱。但是选中后可能会造成浏览器访问次数或 CDN 回源次数增加。 样式错乱，与网页不一 部分 css 样式不兼容，比如 clac 计算样式等等 下载不了或无反应 可能性： 需要在页面渲染完毕再下载 报错 TypeError: Failed to execute 'addColorStop' on 'CanvasGradient' 可能性： 页面渲染后存在两个相同 canvasId 的 canvas 参考 html2canvas 实现浏览器截图的原理（包含源码分析的通用方法） html2canvas 兼容性 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"前端工具/h函数.html":{"url":"前端工具/h函数.html","title":"h函数","keywords":"","body":"h 函数 Vue 提供了一个 h() 函数用于创建 vnodes，h() 是 hyperscript 的简称，意思是“能生成 HTML (超文本标记语言) 的 JavaScript”。这个名字来源于许多虚拟 DOM 实现默认形成的约定。一个更准确的名称应该是 createVNode()，但当你需要多次使用渲染函数时，一个简短的名字会更省力。 特点 h() 函数的使用方式非常的灵活 编写时为对象形式 属性为驼峰格式或 ['xx-xx'] 格式 方法名变化 onClick 或对象形式 h('div', null, [ h( 'div', { style: { marginTop: '10px' }, props: { value: xx }, on: { input: (value) => { this.value = xx }, change: (value) => { xx } } }, { default: () => [ '审核建议：', h(ElInput, { modelValue: var1.value, 'onUpdate:modelValue': (val: string) => { var1.value = val }, placeholder: '请输入', type: 'textarea', minRows: 4, maxlength: 1000, showWordLimit: true }) ] } ) ]) \"Non-function value encountered for default slot.\" Vue3 使用 h 函数推荐使用函数式插槽，以便获得更佳的性能 如果组件定义了插槽，需要定义一个匿名函数返回 h 函数，即使是默认也要显性写出来 default。 // 错误 return h(xxx, { xxx }, { xxx }) // 正确 return h(xxx, { xxx }, { default: () => xxx }) // 多个插槽 return h( xxx, { xxx }, { default: () => [xxx, xxx], }) Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:36:25 "},"前端工具/postmessage.html":{"url":"前端工具/postmessage.html","title":"Postmessage","keywords":"","body":"postMessage 跨窗口通信 1.父窗口给子窗口发送消息的方式： iFrame.contentWindow.postMessage('MessageFromIndex1','_'); 其实就是在父窗口中操作子窗口发消息，然后让子窗口接收自己刚才发的消息。 2.子窗口给父窗口发送消息的方式： parent.postMessage({msg: 'MessageFromIframePage'}, '_'); 注意：此处 parent === window.parent，即子窗口的父窗口。 其实就是在子窗口中操作父窗口发消息，然后让父窗口接收自己刚才发的消息。 总结：所谓的跨窗口发送消息，就是通过在别的窗口操作本窗口发送消息，然后本窗口再自己接收的方式实现。 // 子页面 // 子窗口传父 function sendMessage() { // top = window.parent = window.top top?.postMessage( { data: { code: 'success', text: '子頁面的test', }, }, '*' ) } // 子窗口接收父 const result = ref({}) window.addEventListener( 'message', (event: any) => { result.value = event.data.data }, false ) // 父窗口 // 父接收子 const result = ref() onMounted(() => { window.addEventListener('message', (event: any) => { const data = event.data.data if (data?.code === 'success') { ElMessage(data?.text) result.value = data?.text } }) // 父发子先定义 myFrameInstance.value = myFrameRef.value?.contentWindow }) // 父发子 const myFrameRef = ref() const myFrameInstance = ref() function sendMessage() { myFrameInstance.value.postMessage( { data: 'Hello Message From Bi!', }, '*' ) } 可参考库：https://github.com/dollarshaveclub/postmate window.top.postmessage 和 window.postmessage window.top.postmessage 才能传值 window.top.postMessage({ name: 'test' }, '*') 多窗口嵌套传值 const sendData = {} const windowList = [] function getWindow (currentWindow) { if (currentWindow.top.opener) { // 多窗口层级 if (currentWindow.top.vm) { // 新后台 return currentWindow.top } else { windowList.push(currentWindow.top) return getWindow(currentWindow.top.opener) } } else { // 只有一个层级 return currentWindow.top } } function closeWindows() { windowList.forEach(item => { if (item === window) { setTimeout(() => { item.close() }, 1) } else { item.close() } }) } getWindow(window).postMessage(sendData, '*') closeWindows() window.opener.xx 父：window.xx = () => {} 子： window.opener.xx() widnow.close() MessageChannel https://www.jianshu.com/p/4f07ef18b5d7 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:42:22 "},"前端工具/tsx.html":{"url":"前端工具/tsx.html","title":"Tsx","keywords":"","body":"tsx SFC：Vue 单文件组件 TSX：TypeScript 文件，包含 JavaScript XML（JSX） // pnpm install @vitejs/plugin-vue-jsx -D import { defineConfig } from \"vite\" import vue from \"@vitejs/plugin-vue\" import vueJsx from \"@vitejs/plugin-vue-jsx\" export default defineConfig({ plugins: [ vue(), vueJsx() //插件使用 ], css: { modules: { // 规定css类名的命名规则为小驼峰，即 child-item css 类在 js 中会变成 childItem 变量 localsConvention: 'camelCase' } }, }) classnames classNames('foo', 'bar') // => 'foo bar' CSS Modules css module 把 css 作为模块引入到 js 中，是一种技术流的组织css代码的策略，它将为css提供默认的局部作用域。 css module 对 css 文件命名有要求，必须在后缀名前面是module，例如xxx.module.css、xxx.module.less、xxx.module.scss。 vite.config.ts css: { modules: { // 规定css类名的命名规则为小驼峰，即 child-item css 类在 js 中会变成 childItem 变量 localsConvention: 'camelCase' } }, const TsxDemo = defineComponent({ setup() { return () => { return ( <> {/* OR */} ) } }, }) export default TsxDemo 编译和使用 css module 会在编译的时候自动把类名加上一个哈希字符串，而使用 global 声明的 class 不会在编译的时候被加上哈希字符串。 index.module.scss /** 形式一 */ .demo-normal { .normal-test { background-color: red !important; } } // 形式一会编译成： ._react-demo_1e21d_6 ._demo-test_1e21d_6 { background-color: red !important; } /** 形式二 */ .demo-global { :global { .global-test { background-color: red !important; } } } // 形式二会编译成： ._react-demo_86lo7_6 .demo-test { background-color: red !important; } 类名使用引用的方式会被编译成哈希字符串的，global 声明则不能用引用的方式。 // 形式一 normal // 形式二 global global 全局作用选择器 statistics.module.scss // react，如果我们想要覆盖第三方的组件样式，用自己写的选择器名称是覆盖不了的，因为加了哈希字符串之后与组件默认样式的选择器名称不匹配；而使用 global 声明的 class，不会在编译的时候被加上哈希字符串，从而可以实现覆盖默认样式的效果。 .table-wrap { :global { .el-table td.el-table__cell, .el-table thead.is-group th.el-table__cell { padding: 5px !important; } } } // 区别 vue，即使用一个唯一的类名包着也会作用到有用到该类名的全局样式，慎用 // 比如在下方例子中，其他文件用了 .test 类名也会被影响到 .notice-dialog { :global(.el-dialog.is-fullscreen) { min-width: 900px !important; } :global(.test) { background-color: red !important; } } Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:48:07 "},"前端工具/vite.html":{"url":"前端工具/vite.html","title":"Vite","keywords":"","body":"vite Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。 构建 构建产物分析 产物分析 package.json \"scripts\": { \"dev\": \"vite\", \"build\": \"tsc && vite build -w\" } pnpm dev pnpm dev // 直接访问 http://127.0.0.1:5173/ 更新生效 入口 index 文件是：root/index.html（Vite App ROOT） 监听的是 root/index.html 文件，该文件变化就会变化，包括引用的文件源码；结果可能不准 pnpm build pnpm build，build 完后 public 下的内容会复制过去，入口 index 文件是：root/public/index.html（Vite App Public），然后 open with live server，访问：http://127.0.0.1:5500/dist/index.html。如果被监听文件更新了需要刷新页面。若加了 -w 会持续监听并 build。 环境变量 vite build 默认运行生产模式构建，你也可以通过使用不同的模式和对应的 .env 文件配置来改变它，用以运行开发模式的构建。 模式配置： import.meta.env.DEV: 是否运行在开发环境(NODE_ENV=development) import.meta.env.PROD: 是否运行在生产环境(NODE_ENV=production) rollup 代码分割 manualChunks 在 vite 配置文件，通过 build.rollupOptions.output.manualChunks 配合手动分包策略之后，vite 会自动生成 vendor 包 当页面越来越多，配置了动态引入页面之后，打包出来会产生 chunk 碎片，如几个页面公用的文件 api.js sdkUtils.js http.js 等，这些独立的分包大小都很小，加起来 gzip 之后都不到 1kb，增加了网络请求 /** * 分割第三方依赖包，解决 vendor 包过大，合并多处引用的文件，解决 chunk 碎片 * chunk 拆包优化；依赖和构建后的文件有问题 */ const vendorLibs: string[] = ['element-plus', 'jspdf', 'lodash', 'axios', 'vue-router'] export const configManualChunk = (id: string, { getModuleInfo }: any) => { // 分割第三方依赖包，解决 vendor 包过大 if (/[\\\\/]node_modules[\\\\/]/.test(id)) { const matchItem = vendorLibs.find(item => { const reg = new RegExp(`[\\\\/]node_modules[\\\\/]_?(${item})(.*)`, 'ig') return reg.test(id) }) return matchItem ? matchItem : 'vendor' } if ( // 合并多处引用的文件，解决 chunk 碎片 getModuleInfo(id).importers.length + getModuleInfo(id).dynamicImporters.length > 2 ) { return 'manifest' } } 解决 chunk 碎片问题 Vite - 代码分割策略 重写分包策略后报错 vendor 模块中会导入 manifest 中导出的 jsx-runtime 依赖，而 manifest 中这个依赖又是从 vendor 中导入的。 开发环境页面加载问题慢 解决：升级 vite3 到 4 可解决 Vite 的首屏性能为什么不好 vite 性能优化 — 增加业务代码预构建，加快首屏输出 升级 vite 3 到 4 步骤： vite 安装 4 后，执行 pnpm i 查看相对应的 peer 依赖应该是多少。 联动 peer 依赖更新，比如：vitejs/plugin-vue vitejs/plugin-vue-jsx unplugin-icons unplugins-element-plus 测试页面 出现的问题： element-ui 下拉框组件出现异常，与 ui 版本有关。 element-plus el-select updateOptions emit 报错：[Vue warn]: Extraneous non-emits event listeners (updatedcount) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option 目前解决：将 element-plus 降级到没有 updateOptions emit 即 2.2.32 恢复正常。还原相同环境测试 vue 相关的 emit 无问题，应该是 element-plus 问题，具体问题待确定。 https://cn.vitejs.dev/guide/migration.html https://github.com/element-plus/element-plus/commits/dev/packages/components/select/src/options.ts https://github.com/element-plus/element-plus/pull/11868 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:11:42 "},"技术优化/node内存溢出.html":{"url":"技术优化/node内存溢出.html","title":"node内存溢出","keywords":"","body":"node 内存溢出问题 Node 进程的内存限制是有限的，当前在默认情况下，V8 在 32 位系统上的内存限制为 512mb，在 64 位系统上的内存限制为 1gb，所以有些项目在加了 Babel 后在构建时可能会出现内存溢出的问题。可以通过将 --max-old-space-size 的值提高，但是如果达到内存限制，还可以将单个进程拆分为多个工作进程。 解决方法 windows 方式一：VSCode 工作区设置 .vscode/settings.json { \"terminal.integrated.env.windows\": { \"node_options\": \"--max_old_space_size=3072\" } } 方式二：在 package.json 中设置 package.json \"scripts\": { \"serve\": \"vue-cli-service serve --max_old_space_size=3072\", } 方式三：在终端进程中设置 set NODE_OPTIONS=--max-old-space-size= // 单开终端 export NODE_OPTIONS=\"--max-old-space-size=8192\" // 永久终端 macos macos 在.bash_profile 下加入 export NODE_OPTIONS=--max_old_space_size=3072 https://www.cnblogs.com/caofeng11/p/13160416.html windows 和 macos 通用的方式，使用 cross-env 跨平台设置环境变量 npm install -D cross-env \"scripts\": { \"serve\": \"cross-env NODE_OPTIONS=--max_old_space_size=3072 vue-cli-service serve\", }, https://blog.csdn.net/wuyujin1997/article/details/122869951 更多可参考： 详细配置 nodejs 设置应用的内存上限 NODE_OPTIONS=--max-old-space-size=8192 node 内存溢出了？ 看看这篇。 其他 Node.js heap out of memory 升级 node 版本 运行以下命令 npm install -g increase-memory-limit increase-memory-limit https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"技术优化/vue-cli3.x项目webpack优化.html":{"url":"技术优化/vue-cli3.x项目webpack优化.html","title":"vue-cli3.x项目webpack优化","keywords":"","body":"vue-cli3.x 项目 webpack 优化 terser-webpack-plugin 该插件可以压缩 JavaScrip 和在构建时一键去掉调试打印语句 安装： $ npm install terser-webpack-plugin@3.1.0 --save-dev 配置： vue.config.js const TerserPlugin = require('terser-webpack-plugin') configureWebpack: config => { if (process.env.NODE_ENV === 'production') { return { optimization: { minimize: true, minimizer: [ new TerserPlugin({ cache: true, parallel: true, sourceMap: false, terserOptions: { compress: { drop_console: true, drop_debugger: true, // pure_funcs: ['console.log'], // 移除console }, }, }), ], }, } } 参考链接： https://v4.webpack.docschina.org/configuration/optimization/#optimization-minimizer https://github.com/webpack-contrib/terser-webpack-plugin https://github.com/terser/terser#minify-options compression-webpack-plugin 压缩静态资源，服务端在 Nginx 开启 Gzip 属性。Nginx 在访问资源时，如果该资源有 gz 文件，则会请求 gz 文件。 安装： $ npm install compression-webpack-plugin --save-dev 配置： vue.config.js const CompressionPlugin = require('compression-webpack-plugin') // 引入gzip configureWebpack: config => { if (process.env.NODE_ENV === 'production') { return { plugins: [ // 添加gzip new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, threshold: 10240, deleteOriginalAssets: false }), ] } } 参考： https://v4.webpack.js.org/plugins/compression-webpack-plugin/ 分析打包速度 speed-measure-webpack-plugin https://github.com/stephencookdev/speed-measure-webpack-plugin 只针对 plugins Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"技术优化/web-worker.html":{"url":"技术优化/web-worker.html","title":"Web Worker","keywords":"","body":"webworker 一个独立于 JavaScript 主线程的独立线程，在里面执行需要消耗大量资源的操作不会堵塞主线程。 JavaScript 是单线程的语言，如果在浏览器中需要执行一些大数据量的计算，页面上的其他操作就会因为来不及响应而出现卡顿的情况，Web Worker 的出现为 js 提供了一个多线程的环境，让更多复杂计算拿到另一个环境中去完成，计算完之后再提供给主进程使用，前端页面可以只负责界面渲染，让用户体验更流畅。 Web Worker 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。 Web Worker 在处理一些复杂的计算或耗时的任务时非常有用，可以提高网页的性能和响应能力。然而，它并不适用于所有情况，需要根据具体的应用场景和需求来决定是否使用 Web Worker。 web workers 已经被大多数浏览器支持，使用上基本不用考虑兼容问题。 使用限制 同源限制 接口限制（由于 Web Worker 运行在独立的线程中，它无法直接访问主线程的 DOM、全局变量和大多数浏览器 API。window 作用域下的部分方法不可使用，如 DOM 对象、window.alert 和 window.confirm 等方法。） 文件限制（无法加载本地 js 文件，必须使用线上地址。） 记得关闭（worker 会占用一定的系统资源，在相关的功能执行完之后，一定要记得关闭 worker，无论是在主线程关闭 worker，还是在 worker 线程内部关闭 worker，worker 线程当前的 Event Loop 中的任务会继续执行。至于 worker 线程下一个 Event Loop 中的任务，则会被直接忽略，不会继续执行。但是在主线程关闭则通信会被关闭，不会再接收到信息，worker 线程关闭则会在当前 Event Loop 中接收） 使用时注意 this 指向 webworker 的使用 通过 postMessage 实现主线程和 Web Worker 双向通信 关键代码： const worker = new Worker('xx url') worker.onmessage = (e) => {e.data} worker.postMessage('xxx') worker.addEventListener(event: 'error' | 'messageerror', (err) => {}) worker.terminate() self.onmessage = (e) => {e.data} self.postMessage('xxx') self.addEventListener(event: 'error' | 'messageerror', (err) => {}) self.close() import React, { Component } from 'react' import worker_script from './worker-script' export default class PageHome extends Component { constructor(props) { super(props) this.state = {} } componentDidMount() { const worker = new Worker(worker_script) worker.postMessage('dadada') worker.onmessage = function (event) { console.log(`Received message ${event.data}`) // 执行完了以后关闭 webworker // worker.terminate() } } } worker-script.js const workercode = () => { // 在后台执行任务 self.onmessage = function (e) { console.log('Message received from main script') let workerResult = performData(e.data) self.postMessage(workerResult) } function performData(data) { // 执行耗时的某些操作 return `Received from main: ${data}` } } // 在线生成同源线上地址 let code = workercode.toString() code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}')) const blob = new Blob([code], { type: 'application/javascript' }) const worker_script = URL.createObjectURL(blob) export default worker_script @koale/useworker react hooks import React from 'react' import { useWorker } from '@koale/useworker' const numbers = [...Array(5000000)].map(e => ~~(Math.random() * 1000000)) const sortNumbers = nums => nums.sort() const Example = () => { const [sortWorker] = useWorker(sortNumbers) const runSort = async () => { const result = await sortWorker(numbers) // non-blocking UI console.log(result) } return ( Run Sort ) } 参考 https://juejin.cn/post/7139718200177983524 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:53:11 "},"跨端方案/":{"url":"跨端方案/","title":"跨端方案","keywords":"","body":"[译] React Native vs. Cordova、PhoneGap、Ionic，等等 原生的定义 软件是关于如何操作大量晶体管和电路 (两者统称为硬件) 的指令的集合。直接运行在硬件上的原始指令对我们人类来说是几乎无法理解的, 特别是考虑到当今计算机的复杂性和规模。 要使得软件可以理解和操作的话，计算机科学家将其划分为多个层，这些层均是由框架构成的，每个框架都运行在另一个框架之上。在所有框架中，越接近硬件的框架，我们就说它更“原生”。 严格来说，我们无法说一个应用本身是否是原生的。我们只能说，相比于另一个应用，它是更原生的。 框架 在 React Native 出现之前，移动端框架一般分为两个阵营。 首先是原生阵营，例如安卓的 Java/Kotlin 和 IOS 的 Objective-C/Swift 。 另外一个阵营就是以 Cordova/PhoneGap 和 Ionic 为代表的 WebView 框架。WebView 框架是在原生框架之上构建的，类似于 web 浏览器，可以同时运行在安卓和 IOS 平台上(还可以有更多平台)。这些框架可以让 Web 开发人员使用他们已经具备的 HTML、CSS 和 JavaScript 技能来开发应用。但是，相比于原生应用，这类应用会没有那么流畅，能访问的硬件功能也有限。 React Native 代表的是移动端框架的第三阵营。React Native 直接运行在原生框架里，它的 UI 层要比 WebView 框架更原生，而其余部分处于模拟层，以实现其易用性。 WebView 框架 基于 HTML5 的跨平台技术比较出名的有 PhoneGap、Cordova，常常用于开发 webapp，还有 Egret、Cocos-creator、Unity、weex、uniapp 等，常用于开发游戏；还有基于 node 的 nw.js，用于开发桌面应用，以及 Electron，一款比 nw.js 还强大的用网页技术来开发桌面应用的神器。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"跨端方案/apicloud.html":{"url":"跨端方案/apicloud.html","title":"Apicloud","keywords":"","body":"apicloud 需付费的可视化低代码开发运营平台 web app 搭建流程 准备工作 手机安装 Apploader，支持 Android & iOS 电脑安装编辑器 APICloud Studio 3，安装好以上两个软件后可用于 APP 开发过程的真机快速调试 在apicloud创建账号 使用 在编辑器登录账号，新建 Native App 项目后即可同步到云控制台，项目中只保留项目中config.xml文件 config.xml 节选部分，关键看以下配置 // 需要跟云项目中id一致 // 链接对入口文件，可以是局域网ip或编译好的项目文件入口 真机调试 以 vue-cli4 项目为例，打包前需修改以下地方： 路由配置为 hash 模式 配置 vue.config.js 文件： publicPath: './' 多页面配置 wifi 同步：链接项目入口后，右键项目根路径打开 WIFI 同步 教程 新手开发指南：https://docs.apicloud.com/APICloud/junior-develop-guide 官方教程：https://www.apicloud.com/video_list#plugins 图文教程：https://juejin.cn/post/6973441944374476831#heading-0 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"跨端方案/electron.html":{"url":"跨端方案/electron.html","title":"Electron","keywords":"","body":"electron electron 分为两个进程主进程和渲染进程 主线程：index.js Remote 模块: 在渲染进程里（比如 index.html 里面加载了一些 js 文件，那里面的 js 如果要使用到 BrowserWindow 这些属性的话就必须使用 remote）使用 remote 模块, 你可以调用 main 进程对象的方法 调试 # 开发热更新 $ nodemon --watch . --exec electron . electron 编译安装包 electron 安装+运行+打包成桌面应用+打包成安装文件+开机自启动 应用程序的绿色版本：无需安装，拷贝整个文件目录之后即可使用 客户端应用程序安装包：安装之后通过桌面快捷方式的形式去访问（Inno Setup） # 安装electron打包工具electron-packager $ npm install electron-packager -g # 编译绿色安装包 $ electron-packager . appName --win --out ./appName --arch=x64 --app-version=1.0.0 --electron-version=1.0.0 --overwrite --icon=./src/assets/favicon.ico --ignore=node_modules # 客户端应用程序安装包 Inno Setup 通过软件向导生成 setup.exe electron-packager electron-packager 的命令结构如下（根据实际情况修改）： .：需要打包的应用目录（即当前目录） appName：应用名称 --win：打包平台（以 Windows 为例） --out ../appName：输出目录 --arch=64：64 位 --app-version=0.0.1：应用版本 --electron-version=2.0.0：项目使用的 electron 版本 electron-packager 编译的安装包跑不起来： 有报错说明代码或调用出问题，会出现在线预览没事，但编译包就出问题 编译包定义的 electron 版本是否与项目用的一致，新版本可支持更多 api Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"跨端方案/flutter.html":{"url":"跨端方案/flutter.html","title":"Flutter","keywords":"","body":"flutter 一个跨平台 UI 解决方案 DART Dart 是一种适用于万维网的开放源代码编程语言，由 Google 主导开发，于 2011 年 10 月公开。它的开发团队由 Google Chrome 浏览器 V8 引擎团队的领导者拉尔斯·巴克主持，目标在于成为下一代结构化 Web 开发语言。 类似 JavaScript，Dart 也是一种面向对象语言，但是它采用基于类编程。 在本地运行 Dart 代码需要先安装 Dart Sdk，将 Dart 可执行文件添加环境变量 art2js 工具用于将 Dart 代码编译为 JavaScript。 将 Dart 代码编译为 JS 可以在不支持 Dart VM 的浏览器上运行 Dart 脚本。 https://flutter-io.cn/docs/get-started/flutter-for/web-devs Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"跨端方案/mpvue.html":{"url":"跨端方案/mpvue.html","title":"Mpvue","keywords":"","body":"Mpvue Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"跨端方案/uni-app.html":{"url":"跨端方案/uni-app.html","title":"Uni App","keywords":"","body":"uniapp 调试 官方调试教程 HBuilder 内置浏览器 优点：在线同步运行前端项目，边改边看，接口可跨域成功，可查看请求信息 弊端：运行不了 html5+ 相关的 真机调试 连接方式：usb 连接好后，通过【运行】-【运行到手机或模拟器】-【运行到 Android app 基座】 优点：可还原手机 app 运行环境；可以热更新 弊端：更新一点点都要重启 app，如果配置了账号密码、环境都要重新设置；需要抓包看网络请求；android 可用，ios 不可（截止至 22.10.25） 模拟器 优点：可还原手机 app 运行环境；可以热更新 弊端：windows 只能运行安卓模拟器；需要抓包看网络请求；运行有点慢 连接教程大部分可以参考: https://www.jianshu.com/p/f01efc0e4609 检查模拟器连接情况：新版本 HbuilderX 行不通了，可通过【运行】-【运行到手机或模拟器】-【运行到 Android app 基座】查看是否有设备名类似为【127.0.0.1:7555】 运行成功后一直闪退问题：回退 Hb 版本 3.4.x 之后 打开调试控制台：【视图】-【显示 webview 调试控制台】 # 连接 adb connect 127.0.0.1:7555 adb devices # HbuilderX 默认安卓端口26944 模拟器端口号 模拟器通过 bin 文件可以通过终端链接手机，操作内部环境，读写删手机文件 chrome webview 调试 真机或模拟器调试可以用 chrome 调试页面样式，当程序运行到基座后，打开 HubuilderX 的视图 -> 显示 Webview 调试控制台。 chrome 调试 app：https://blog.51cto.com/u_10624715/5270841 uni-app 只有 v3 模式下的 vue 页面支持 webview 调试：https://ask.dcloud.net.cn/article/36599 离线打包 uniapp 分两种更新机制： 完整包更新，包括 wgt 包 + uni 原生引擎 + 原生插件（这种方式比较繁琐，即每次更新之后就要打云包，更新整包，用户体验也不好） 资源包更新，包括 wgt（因第一种方法想到利用资源更新，用户体验大大提升，用户更新之后无需跳转到应用市场或者浏览器去重新更包，即无感更新）。wgt 是资源升级包，完整的前端资源，将前端的全部内容编译打包成 wgt。只有前端资源 wgt 可以热更新。 uniapp 离线打包（wgt）： 配置 manifeat.json 基础配置中的 appID、应用版本名称、应用版本号 点击窗口的【发行】-【原生 app-制作应用 wgt 包】 uni-app 跨平台应用开发之实现资源在线升级 混合开发 uniapp 编译提供的 wgt 包，宿主在原生 app 中 uniapp 向 app 发送指令，通过回调获取信息：uni.sendNativeEvent uniapp 监听 app 的指令：uni.onNativeEventReceive((event, data) => {}) others app 启用小程序时，在 onLaunch(opts) 的 opts 的可以获取到一些信息 获取 app 版本号：opts.referrerInfo.extraData.version 是否 debug 模式：opts.referrerInfo.extraData.isDebug HTML5+ 扩展规范 https://www.html5plus.org/doc/h5p.html HTML5+是中国 HTML5 产业联盟的扩展规范，基于 HTML5 扩展了大量调用设备的能力，使得 web 语言可以想原生语言一样强大。 html5+ 是 hbulider 利用自己的 IDE 结合不同平台的接口再加上 html5 的东西开发出来的一套框架，它有自己的使用规范，它允许和提供了一些接口和函数来让 web 开发者实现原生 app 所能实现的功能，Dcloud（开发 hublider 的公司）还在 hublider 提供了云打包功能，几乎是打包发布，帮那些不熟悉原生开发的开发人员节省了很多时间，国内类似的还有 Apicloud(提供了很多原生模块，而且编译发布什么的要比 hbulider 好一些，SDK 更新的比较勤，维护还是做的很不错的，最近在和 Dcloud 打官司)。hublider 的 native.js 就是一个接口库，调里面的接口就可以利用 hbulider 为你实现的和原生 api 结合的一些功能。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"跨端方案/uniapp.html":{"url":"跨端方案/uniapp.html","title":"Uniapp","keywords":"","body":"uniapp 常用 uniapp 生命周期执行顺序 // 进入应用 App Launch App Show page onLoad page onShow component beforeCreate component created component mounted page onReady // 应用后台 App Hide page onHide // 应用关闭 page onUnload component destory // 后台重新进入 App Show page onLoad page onShow 带来的问题： 每次切换页面的时候，组件的生命周期 created mounted，只能触发一次，解决方法：ref，在父组件的 onShow 调用子组件的方法 生命周期： 如果页面没有销毁但隐藏会触发 onHide，销毁也隐藏了触发 beforeDestroyed，onHide 和 beforeDestroyed 二者只会触发一次 onLoad 和 onShow navigateTo 调转，下一页会触发 onload 和 onshow，返回会触发 beforeDestroy 小程序缩小到后台，切换 app 再返回小程序会触发 onhide onshow 总结：除想要每次显示小程序都处理某些逻辑要使用 onShow，否则最好用 onload uniapp 跨组件触发事件 uni.$emit('xxx') .... 小程序分包 小程序主包最多只能 2M 的限制，当一个主包文件过多时，肯定面临着性能低，卡顿的情况。所以采用了分包的加载机制，将各个模块解耦。总包 20M 降低主包大小 外部根目录的 components 优化，只放使用率高的组件 尽量多分包，分包数量可支持 10 个左右，总包大小 20M 图片除底部栏外尽量使用网络图片 升级微信开发者工具，可提高打包效率压缩代码 打包原则 app（主包）也可以有自己的 pages（即最外层的 pages 字段） tabBar 页面必须在 app（主包）内 subpackages 配置路径外的目录将被打包到 app（主包） 中 声明 subpackages 后，将按 subpackages 配置路径进行打包 subpackage 的根目录不能是另外一个 subpackages 内的子目录 app.json 目录结构 微信原生是在同级分包，但 mpvue 同级会报错的，只能在 pages 中进行分包，在 subpackages 声明项目分包结构 app.json { \"pages\": [\"pages/home/main\", \"pages/tabbarpage.main\"], \"subPackages\": [ { \"root\": \"pages/subPage\", //分包根目录 \"name\": \"\", // 分包别名，分包预下载时可以使用 \"pages\": [ // 分包页面路径，相对于分包根目录 \"page1/main\", \"page2/main\" ], \"independent\": \"\" // 分包是否是独立分包 } ] } uniapp 小程序微信和支付宝端差异 class 和 style 语法 :class=\"xx: Boolean\" 注意事项： Boolean 不能是要通过复杂计算出的布尔，也不能是要经过默认转化的非布尔值 class 为多个值时可能会异常，判断不正确 支付宝兼容问题 组件传值为数组对象时，子组件修改值后支付宝界面未同步更新 子组件通过直接修改数组对象内容，数据都可以修改，微信可以渲染界面，但支付宝不行 可以将值通过 computed 复制一份，在该备份改完以后，forceupdate span 标签注册 click 事件失败，需要转为 div 样式空白屏 当使用 position: absolute;top: 0;bottom: 0; 撑开元素 A 时，需要注意 A 的父元素是否为根元素 body，如果不是需要给一个高度，否则会出现子是撑不开父的。 微信端容错性高，可以展示效果，支付宝不行。 样式边距错乱 支付宝端有时会对 box-sizing: border-box;不生效。如 /* 此时swiper-box的宽是铺满屏幕的，没有边距 */ .main-content-banner { width: 100%; height: 98px; padding-bottom: 16px; position: relative; .swiper-box { width: 100%; height: 98px; box-sizing: border-box; padding: 0 12px; text-align: center; } } 支付宝图片标签如果定义了 padding-bottom，会拉长图片的高，尽量用 margin 图片的背景如果用了 background-size: contain; 会使支付宝端高度不可控，与微信端不一致 vue 数据联动没反应 原则上子组件不能对 props 传值进行修改，包括对象。但微信端可直接引用该 props 对象，再 emit update 修改。支付宝端不行。 所以可采用 computed 复制 props 再引用，修改可用 emit update。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"通用工具/curl.html":{"url":"通用工具/curl.html","title":"Curl","keywords":"","body":"curl CURL (Client Url) 是一个利用 URL 语法在命令行下工作的文件传输工具。 应用 将浏览器的请求转换为 CURL 命令 浏览器端，找一个请求，右击复制格式，会有一个以 curl 格式复制，然后可以直接粘贴到浏览器控制台或终端发送请求，什么请求都可以发，不需要权限，因为复制的时候已经把关键信息带上来 有时候浏览器的请求你觉得不对了，可以直接把这个curl 发给后端 使用命令行往数据库读取数据 # 不带任何参数就是一个 get 请求 $ curl www.baidu.com # -d:post方式 $ curl -d 'name=hong&age=22' http://localhost:3000/users/addPerson 实现某些功能 yarn 版本升级： $ curl -o- -L https://yarnpkg.com/install.sh | bash Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:54:49 "},"通用工具/gitbook.html":{"url":"通用工具/gitbook.html","title":"Gitbook","keywords":"","body":"Gitbook Setup # install $ npm install -g gitbook-cli # begin with nvm v10.24.1 $ gitbook install # generate summary by gitbook-summary $ book sm # or $ gitbook init # ouput $ gitbook build $ gitbook build ./ ./docs # development $ gitbook serve --port 6666 ✨ Gitbook Features GitBook GitBook Plugins generate a SUMMARY.MD via Gitbook Summary Automated deployment via Github Actions choose /docs via Github Pages Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"通用工具/网络抓包Charles.html":{"url":"通用工具/网络抓包Charles.html","title":"网络抓包Charles","keywords":"","body":"网络抓包 Charles Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 charles 下载地址 charles 教程 IOS 设备教程 Charles 抓包安卓模拟器（MuMu） 快速上手 [Charles] 设置系统代理的权限来完成封包截取 选择菜单中的“Proxy” –>“Mac OS X Proxy”或“Windows Proxy” [Charles] 打开代理功能 选择菜单中的“Proxy”–>“Proxy Settings”后编辑 Charles 端口号为 8888，勾上 “Enable transparent HTTP proxying” [iphone] 获取 Charles 的代理功能 在 iphone 当前连接的 wifi 里编辑内容“HTTP 代理“为手动代理，填上 Charles 运行所在的电脑的 IP，以及端口号 8888。（Charles 运行所在的电脑的 IP：Charles 的顶部菜单的 “Help”–>“Local IP Address”） 苹果手机还需要在的设置-通用-证书-允许 charles*** 证书 设置代理后，需要在电脑上配置并打开 Charles 才能上网。 [Charles] 安装证书 选择菜单中的“Help” –> “SSL Proxying” –> “Install Charles Root Certificate” 需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，有以下几种方法： Charles 在该请求上右击，选择 SSL proxy 直接设置所有网站：“Proxy” –> “SSL Proxying Settings”勾选 enable ssl Proxying，添加 include 的端口号*:443 [iphone] 安装证书 点击 Charles 的顶部菜单，选择 “Help” –> “SSL Proxying” –> “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。 如果设置完 HTTPS 代理 和证书之后，则所有的请求数据都将以明文显示，网络包不会显示错误 X 真机调试 真机测试：fiddler Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/":{"url":"项目工程化/","title":"项目工程化","keywords":"","body":"项目的工程化和自动化是一件很有意思的事情，通过自动化的工具，可以有效提升项目可维护性和质量，节省人力资源，并且避免很多不确定因素。 前端自动化/持续集成/持续部署 CI/CD： 前后端分离后，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节，提高了前端的开发效率和业务交付能力 工具：github、jenkins 前端开发如何让持续集成/持续部署(CI/CD)跑起来 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/github-action.html":{"url":"项目工程化/github-action.html","title":"Github Action","keywords":"","body":"使用 Github Actions 自动部署 vitepress 到 Github Pages 获取 token vitepress 教程 修改包管理器为 pnpm：setup-node Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/monorepo.html":{"url":"项目工程化/monorepo.html","title":"Monorepo","keywords":"","body":"monorepo 方案 pnpm workspaces yarn workspaces lerna + yarn workspaces pnpm workspaces 🌰： hazel-plus(ui) 两个官网重构合并（nuxt2.17） 两个官网重构合并（nuxt2.17） pnpm 配置，使用旧 npm 安装依赖的方式 .npmrc shamefully-hoist=true auto-install-peers=true strict-peer-dependencies=false 项目中的别名 alias 重新定义引用路径 import { resolve } from 'path' const config = { alias: { '@': resolve(__dirname, '../..'), }, } 配置 ts 类型解析路径 tsconfig.json { \"extends\": \"./tsconfig.base.json\", \"compilerOptions\": { \"baseUrl\": \"../../\", \"paths\": { \"@/*\": [\"./*\"] } } } pnpm workspaces 项目部署 经常会有异常报错，如本地编译构建正常，发线上部署则报错，坑点可能是依赖问题，lock 文件没有锁好，某个依赖被升级了然后导致问题 workspaces Quick Start：用 pnpm 管理 Monorepo 项目 link 机制 在 monorepo 中，我们往往需要解决 package 间的引用，比如 @panda/tools 会被 @panda/server 和 @panda/web 依赖。 \"dependencies\": { \"@panda/tools\": \"workspace:^1.0.0\", // 通过 workspace 为本地引用 }, 通过软链接引用了 tools package，可以在 web 项目下的 node_modules 看到对应的代码已经提升了。 发布 workspace 包 当这样的工具包被发布到平台后，如何识别其中的 workspace 呢？ 需要 workspace 包打包到归档，可以通过pnpm pack 或 pnpm publish 之类的发布命令，将动态替换这些 workspace 依赖，把基于的 workspace 的依赖变成外部依赖，解决了开发环境和生产环境对依赖的问题。 注意：必须是用 pnpm 的命令才能起效 yarn workspaces package.json 配置 { \"private\": true, \"license\": \"MIT\", \"version\": \"1.0.0\", \"workspaces\": [\"apps/*\"], \"scripts\": { \"xxx:dev\": \"yarn workspace xxx run dev\" } } lerna + yarn workspaces https://blog.csdn.net/frontend_frank/article/details/115344129 # 全局安装，lerna 测试版本为 5.6.2 $ npm install -g lerna@5.6.2 # 空项目初始化 lerna 项目 $ lerna init # 执行 apps 项目下 xxx-a 项目的 script 指令 dev，如果不加 --stream，运行结果只会提示最后一句 run dev 就什么信息都不会报 $ lerna run dev --scope xxx-a --stream # 查看 lerna 指令 $ lerna run --help 如果在旧项目重构成 lerna monorepo 项目则手动加 lerna.json 文件 lerna.json { \"$schema\": \"node_modules/lerna/schemas/lerna-schema.json\", \"version\": \"independent\", // lerna默认使用的是集中版本，所有的package共用一个version,如果需要packages下不同的模块 使用不同的版本号，需要配置Independent模式 \"packages\": [\"apps/*\"], \"useWorkspaces\": true, \"npmClient\": \"yarn\", \"useNx\": false } turborepo https://turbo.build/ Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/rollup-pack-node.html":{"url":"项目工程化/rollup-pack-node.html","title":"Rollup Pack Node","keywords":"","body":"rollup 打包 node commonjs 项目 使用 rollup 打包启动项目 rollup.config.mjs // pnpm add -D @rollup/plugin-commonjs @rollup/plugin-node-resolve import resolve from '@rollup/plugin-node-resolve' import commonjs from '@rollup/plugin-commonjs' export default [ { plugins: [resolve(), commonjs()], input: './packages/Json2Interface/index.js', output: { file: './dist/index.js', format: 'cjs', }, external: ['chalk', 'commander', 'inquirer', 'ora', 'request', 'fs', 'quicktype-core'], }, ] package.json { \"scripts\": { \"rollup:Json2Interface\": \"rollup -c rollup.config.mjs\" } } // 使用 const { output } = require('../dist/index.js') Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/vite-pack-node.html":{"url":"项目工程化/vite-pack-node.html","title":"Vite Pack Node","keywords":"","body":"vite 打包 node commonjs 项目 vite.config.js // pnpm add -D vite-plugin-commonjs import commonjs from 'vite-plugin-commonjs' import { resolve } from 'path' export default { plugins: [ commonjs({ include: /Json2Interface/, extensions: ['.js'], // 需要转换的文件扩展名 ignoreGlobal: false, // 是否忽略全局变量（例如 Buffer） sourceMap: false, // 是否生成源映射 namedExports: {}, // 命名导出（名称和值） ignore: [], // 忽略文件的正则表达式 transformMixedEsModules: true, // 是否转换混合的 ES 模块 }), ], build: { target: 'modules', minify: true, lib: { entry: './index.js', name: 'Json2Interface', }, rollupOptions: { external: ['chalk', 'commander', 'inquirer', 'quicktype-core', 'ora', 'request', 'fs'], input: ['./index.js'], output: [ { format: 'cjs', //不用打包成.mjs entryFileNames: '[name].js', //让打包目录和我们目录对应 preserveModules: true, //配置打包根目录 dir: resolve(__dirname, '../../dist/Json2Interface'), }, ], }, }, } package.json { \"scripts\": { \"build:Json2Interface\": \"pnpm --filter=Json2Interface build\" } } // 使用 const { output } = require('../dist/Json2Interface/index.js') Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/代码提交规范.html":{"url":"项目工程化/代码提交规范.html","title":"代码提交规范","keywords":"","body":"git commit 代码提交规范 Conventional Commits 约定式提交 统一团队 Git Commit 标准，便于后续代码 review、版本发布、自动化生成 change log 或 release note 可以提供更多更有效的历史信息，方便快速预览以及配合 cherry-pick 快速合并代码 团队其他成员进行类 git blame 时可以快速明白代码用意 校验辅助工具 husky: supports all Git hooks, can lint your commit messages, run tests, lint code, etc... commitlint: Lint commit messages # 安装husky和commitlint $ pnpm add -D husky @commitlint/config-conventional @commitlint/cli # warning: 以下命令适用于husky8 # 安装husky提供的git hook：package.json > prepare script 的prepare脚本会在执行npm install之后自动执行 $ npm set-script prepare \"husky install\" $ npm run prepare # git hook(pre-commit)：提交git commit命令前触发，脚本内容自定义，一般添加eslint $ npx husky add .husky/pre-commit \"xxx\" # git hook(commit-msg)：规范 commit message 信息，需要配置commitlint $ npx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"' $ echo \"module.exports = {extends: ['@commitlint/config-conventional']}\" > commitlint.config.js 配置 commitlint 时 Windows 可能出现的问题： 文件编码格式应该为 UTF-8 package.json 中的 type 属性配置：commitlint.config.js -> \"commonjs\"，commitlint.config.cjs -> \"module\" @commitlint/config-conventional 类型默认包括：[build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] commit 说明 例子： feat(cli): create initial commit fix: feat(0429 留言下单): add 'graphiteWidth' option 规范： type(scope): subject type：用于说明 commit 的类别，规定为如下几种： feat：新增功能（feature） fix：修复 bug style：仅仅修改了空格、缩进等，不改变代码逻辑 refactor：代码重构，未新增任何功能和修复任何 bug chore：非 src 和 test 的修改构建过程或辅助工具的变动（杂项） docs：修改文档（documentation） perf：改善性能和体现的修改 test：测试用例的修改 ci：自动化流程配置修改 revert：回滚到上一个版本 build：改变构建流程，新增依赖库、工具等（例如 webpack 修改）(可选） scope：【可选】用于说明 commit 的影响范围，比如: route, component, utils, build... subject：commit 的简要说明，不超过 50 个字符，以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes 第一个字母小写结尾不加句号（.） 如果修改范围以上都应用不了，可能就是 commit 合并太多 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/代码校验.html":{"url":"项目工程化/代码校验.html","title":"代码校验","keywords":"","body":"代码校验 eslint 使用 eslint 来预先制定编码规范，借助编辑器的错误检测和格式化来格式化代码，有效控制代码质量，也省去了很多手工操作。 在项目根目录添加 .eslintrc.js 文件，用于校验代码，编写 eslint 相关规则。 配置 全局配置 使用全局安装 ESLint 后，使用的任何 ESLint 插件或可分享的配置也需要全局安装。 # 全局安装 $ pnpm add -g eslint # 在有 package.json 文件的项目中初始化 $ eslint --init 在 VSCode 配置文件 setting.json setting.json { // 如果使用 yarn 全局安装 eslint，要在 vscode 编辑器的 setting.json 改变此项 \"eslint.packageManager\": \"yarn\", \"eslint.options\": { // 指定 .eslintrc.js 配置文件路径即可启用自定义规则检测，ESLint 会查找并自动读取 \"configFile\": \"E:/git/github/styleguide/eslint/.eslintrc.js\", // ESLint 默认只支持 js 文件的脚本检测，如果我们需要支持类 html 文件（如 vue）的内联脚本检测，还需要安装 eslint-plugin-html 插件 \"plugins\": [\"html\"] }, \"eslint.validate\": [\"javascript\", \"javascriptreact\", \"html\", \"vue\"] } 项目配置 如果仅仅想让 ESLint 成为项目构建系统的一部分，也可以在项目根目录进行本地安装 # 安装 eslint & prettier $ pnpm install -D eslint eslint-config-prettier eslint-plugin-prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-plugin-vue # 初始化 $ pnpm eslint --init 配置好规则文件后，安装编辑器检查插件，比如 vscode 中添加 eslint 和 vetur 插件，安装好了之后，会自动根据你上面配置的规则进行代码检查，不合格的会高亮显示。 具体配置 使用 .eslintrc.* 文件（支持 JSON 和 YAML 两种语法） .eslintrc 放在项目根目录，则会应用到整个项目；如果子目录中也包含 .eslintrc 文件，则子目录会忽略根目录的配置文件，应用该目录中的配置文件。这样可以方便地对不同环境的代码应用不同的规则。 module.exports = { // 指定要启用的环境，以保证在进行代码检测时不会把这些环境预定义的全局变量识别成未定义的变量而报错 env: { browser: true, es6: true, node: true, }, // 启用推荐规则 extends: ['eslint:recommended', 'plugin:vue/essential'], // 脚本在执行期间访问的额外的全局变量 globals: { Atomics: 'readonly', SharedArrayBuffer: 'readonly', }, // 指定解析器 parse: '', // 指定想要支持的 JavaScript 语言选项, 指定解析器选项 parserOptions: { ecmaVersion: 2018, sourceType: 'module', }, plugins: ['vue'], // 启用的规则及其各自的错误级别 rules: {}, // 别人可以直接使用你配置好的ESLint root: true, } 在 package.json 中添加 eslintConfig 配置块 { \"name\": \"mypackage\", \"version\": \"0.0.1\", \"eslintConfig\": { \"env\": { \"browser\": true, \"node\": true } } } 直接在代码文件中定义 代码文件内配置的规则会覆盖配置文件里的规则。 局部禁用 eslint: 单个 js 文件禁用 ESLint 语法校验：在代码顶部添加一行注释 /* eslint-disable */ 禁用某个代码块的校验：在代码块顶部和底部加 /* eslint-disable */ 避开指定的校验规则 /* eslint-disable no-new */ 禁用当前行：在当前行 // eslint-disable-line 禁用下一行：在上一行 // eslint-disable-next-line 忽略校验 在 package.json 配置 \"eslintIgnore\" 或添加文件 .eslintignore 创建自己风格的 eslint 插件 package.json { \"eslintConfig\": { \"root\": true, \"extends\": [\"xxx\"] } } Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/代码格式化.html":{"url":"项目工程化/代码格式化.html","title":"代码格式化","keywords":"","body":"代码格式化 prettier prettier 是一款强势武断的代码格式化工具，它几乎移除了编辑器本身所有的对代码的操作格式，然后重新显示。就是为了让所有用这套规则的人有完全相同的代码。在团队协作开发的时候更是体现出它的优势。与 eslint，tslint 等各种格式化工具不同的是，prettier 只关心代码格式化，而不关心语法问题。 配置 vscode 安装 prettier 插件 全局配置：setting.json 项目配置：prettier.config.js、.prettierrc setting.json // \"prettier.configPath\": \"./prettier.config.js\", \"prettier.printWidth\": 110, \"prettier.tabWidth\": 2, \"prettier.singleQuote\": true, \"prettier.semi\": false, \"prettier.useTabs\": false, \"prettier.trailingComma\": \"es5\", \"prettier.bracketSpacing\": true, \"prettier.arrowParens\": \"avoid\", \"prettier.proseWrap\": \"preserve\", \"prettier.endOfLine\": \"auto\", \"prettier.htmlWhitespaceSensitivity\": \"ignore\", \"prettier.bracketSameLine\": false, \"prettier.vueIndentScriptAndStyle\": true, \"prettier.useEditorConfig\": false, prettier 限制 standard 规则要求函数名和括号之间有一个空格，这就是 space-before-function-paren 规则（ESLint 本身也会默认开启这个规则）。 但是 prettier 完全没有这个规则。 解决： eslint 和 prettier 会有冲突，安装prettier-eslint包 prettier 的一些规则和 eslint 的一些规则可能存在冲突，所以需要将 eslint 的一些可能与 prettier 发生冲突的代码格式化规则关闭。每次 git commit 的时候，要先执行 prettier 以及 eslint 对代码进行格式化和质量检查，确保代码没有问题之后再提交。 Vue 项目使用 eslint + prettier 规范代码风格 prettier-eslint 是怎么让结果变得正确了呢？昨天我去它的 github 看了看，原来它是先把代码用 prettier 格式化，然后再用 ESLint fix。这和 vscode 保存文件时的流程是相反的。这样等于是调转了顺序，最后我们只要 ESLint fix 的结果就行了。 其他点 .prettierrc 的优先级会高于在 vscode 全局配置 settings.json 中格式化配置的优先级 vetur + prettier Vetur 插件内部默认使用 prettier 进行格式化的，但是由于 Vetur 的默认格式化配置与我们期望的有所出入，所以我们需要单独对 Vetur 的 prettier 进行配置 配置 配置格式化方式为 ts setting.json // prettier在格式化的时候 函数名后不会留有空格。需要使用vetur调用vscode自带的ts格式化插件解决这个问题。 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true \"vetur.format.defaultFormatterOptions\": { \"prettier\": { \"semi\": false, // 格式化不加分号 \"singleQuote\": true, // 格式化以单引号为主 \"printWidth\": 120, // 超过最大值换行 \"tabWidth\": 2, // 缩进字节数 \"useTabs\": false, // 缩进不使用tab，使用空格 \"proseWrap\": \"preserve\", // 代码超出是否要换行 preserve保留 \"arrowParens\": \"avoid\", // (x) => {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"{ foo: bar }\" \"disableLanguages\": [\"vue\"], // 不格式化vue文件，vue文件的格式化单独设置 \"endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"eslintIntegration\": true, //不让prettier使用eslint的代码格式进行校验 \"htmlWhitespaceSensitivity\": \"ignore\", \"jsxBracketSameLine\": false, // 在jsx中把'>' 是否单独放一行 \"jsxSingleQuote\": false, // 在jsx中使用单引号代替双引号 \"parser\": \"babylon\", // 格式化的解析器，默认是babylon \"requireConfig\": false, // Require a 'prettierconfig' to format prettier \"stylelintIntegration\": false, //不让prettier使用stylelint的代码格式进行校验 \"trailingComma\": \"es5\", // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号） \"tslintIntegration\": true, // 不让prettier使用tslint的代码格式进行校验 \"ignorePath\": \".prettierignore\" // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 }, \"js-beautify-html\": { // - auto: 仅在超出行长度时才对属性进行换行。 // - force: 对除第一个属性外的其他每个属性进行换行。 // - force-aligned: 对除第一个属性外的其他每个属性进行换行，并保持对齐。 // - force-expand-multiline: 对每个属性进行换行。 // - aligned-multiple: 当超出折行长度时，将属性进行垂直对齐。 \"wrap_attributes\": \"auto\", \"wrap_line_length\": 100 } }, 需要增加其他配置，才能让 vetur 下的 format 生效 setting.json // 默认的格式化程序 【重要】：配置了才会生效 \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, \"vetur.format.defaultFormatter.js\": \"prettier\", // 配置成 prettier，vetur下的prettier才生效 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/无框架项目gulp篇.html":{"url":"项目工程化/无框架项目gulp篇.html","title":"无框架项目gulp篇","keywords":"","body":"官网工程化 - gulp 篇 gulp gulp 是一种基于流的自动化构建工具，基于 nodeJs 中的 stream（流）来读取和写入数据，相对于 grunt 直接对文件进行 IO 读写来说速度更快。 借助于 gulp，我们可以自动化地完成 js/sass/less/css 等文件的的测试、检查、合并、压缩、格式化，并监听文件在改动后重复指定的这些步骤。 要点： 文件压缩（cssnano uglify-js imgmin） babel 转换 图片转 base64 px2rem css 雪碧图 自动添加 css 前缀 autoprefixer 组件复用 代码复用：为了代码的可复用性和可维护性（减少需要变动时的修改范围） 插件gulp-file-include：a plugin of gulp for file include 用法 教程：HTML 代码复用实践 目录： |-node_modules |-src |-include |-index.html |-dist gulpfile.js gulpfile.js var gulp = require('gulp') var fileinclude = require('gulp-file-include') gulp.task('fileinclude', function () { gulp .src('src/index.html') .pipe(fileinclude({ prefix: '@@', basepath: '@file' })) .pipe(gulp.dest('dist')) }) 这里的@file 就是指src/index.html，引入到该页面。basepath 就是指公用组件存在的位置。 tips 最后构建出来的 include 公用文件会合并到 dist/index.html 里。不会生成单独的文件。 src/index.html 引入公共文件时仍需要添加相应的路径：@@include('include/header.html') 但公用文件里设置链接时需要考虑 build 出后的相应路径 因为共用的组件是相同的，所以如果组件里有链接，要使用这个组件的页面需要在同一路径下，才不会链接错误。 css 雪碧图 使用雪碧图：目的是减少网络传输，但设置背景图尺寸大小，感觉很麻烦，而且雪碧图的维护也不怎么便利，好像使用率越来越低了，都被 iconfont 取代了，也可以用构建工具 background-image background-position iconmoon iconmoon 是一个在线工具，可以上传自己的 SVG 格式的图标文件，也可以从其中选择已有的图标， 定制出自己的字体文件。 小图标等用 iconfont 代替：作为单个 DOM 节点使用，可以设置大小、颜色等，非常便利。 个人建议前端来维护这个字体包，每次有新增的图标，让设计师给我们对应的 svg 文件即可，前端自己去 icomoon.io/ 这个网站，导入原来的 selection.json 文件，增量生成新的 css，无比方便。之前，我一直以为 iconfont 只能是单色的呢，其实也可以是多色的，svg 里面多一些 path 而已，设计师会搞定的。生成字体后，前端正常引用即可（引用的时候，多色字体会多一些标签） 使用 base64 格式的图片：有些小图片，可能色彩比较复杂，这个时候再用 iconfont 就有点不合适了，此时可以将其转化为 base64 格式（不能缓存），直接嵌在 src 中，比如 webpack 的 url-loader 设置 limit 参数即可 Writing efficient CSS selectors 私有前缀 css 采用 autoprefixer 或者 prefixfree 等，让 CSS 真正的 Write once, run anywhere。 css 带前缀的是浏览器私有实现，不带前缀的是标准，加前缀是为了兼容 PC 端： 不需要在源代码中写私有有属性前缀了，只需要控制你自己需要兼容什么样的浏览器版本。正确的姿势是在项目构建阶段，用autoprefixer这个工具来为编译后的 css 自动补全所需的前缀。无论你是用 webpack、gulp、grunt 还是 fis，它都能完美配合。 这个工具中内置了非常详尽的数据，描述每个私有有属性在浏览器下的各版本下，是否需要前缀。配置该工具的时候，只要指明需要兼容的浏览器版本，它就会很智能的按需添加前缀了。如果私有语法与标准有差异，它也能自动处理。 只有一种情况下例外，还是要写前缀，那就是你写的这条 css 属性没有对应的 w3c 标准语法。 移动端： 目前大部分设备的浏览器都是基于 webkit 实现的，虽然其它厂商的也有，但不是主流。所以，移动端可以几乎不用加这些私有前缀，个别由于版本迭代，需要加-webkit-前缀兼容低版本的浏览器就行了。 浏览器版本 browserslist 可以写在 package.json 里 https://github.com/browserslist/browserslist#readme \"browserslist\": [ \"last 1 version\", \"> 1%\", \"maintained node versions\", \"not dead\" ] autoprefixer({ browsers: ['last 5 versions', 'Android >= 4.0'], cascade: true, // 是否美化属性值 默认：true 像这样： // -webkit-transform: rotate(45deg); // transform: rotate(45deg); remove: true, // 是否去掉不必要的前缀 默认：true }) gulp 配置 gulpfile.js const gulp = require('gulp') const postcss = require('gulp-postcss') const sourcemaps = require('gulp-sourcemaps') const autoprefixer = require('autoprefixer') // 添加css前缀 const del = require('del') // 清空目录 const concat = require('gulp-concat') // 文件合并 const connect = require('gulp-connect') // 起server服务 const cssnano = require('gulp-cssnano') // 压缩css const htmlmin = require('gulp-htmlmin') // 压缩html const imagemin = require('gulp-imagemin') // 压缩图片 const pngquant = require('imagemin-pngquant') // 压缩png图片 const spritesmith = require('gulp.spritesmith') // 合并sprite图片 const uglify = require('gulp-uglify') // 压缩js const cache = require('gulp-cache') // 缓存资源 const base64 = require('gulp-base64') // 转换图片 const fileinclude = require('gulp-file-include') // 组件复用 const gutil = require('gulp-util') //排错小工具 const preprocess = require('gulp-preprocess') /* CLEAN: 清空dist目录 * ------------------------------------------------------ */ gulp.task('clean', async () => { await del(['./dist']) }) /* HTML: 压缩，开发热更新，生产环境 * ------------------------------------------------------ */ const htmlMin = () => { return gulp .src(['./src/*.html', './src/include/*.html']) .pipe( fileinclude({ prefix: '@@', basepath: '@file', indent: true, }) ) .pipe( htmlmin({ collapseWhitespace: true, minifyJS: true, minifyCSS: true, removeComments: true, }) ) .pipe(gulp.dest('./dist/')) } gulp.task('html:dev', async () => { await htmlMin().pipe(connect.reload()) }) gulp.task('html:build', async () => { await htmlMin() }) /* CSS：前缀、转图片为base64、合并重命名、压缩 * ------------------------------------------------------ */ const cssMin = () => { return ( gulp .src('./src/assets/css/*.css') .pipe(sourcemaps.init()) .pipe(postcss([autoprefixer()])) // .pipe(sourcemaps.write(\".\")) .pipe( base64({ maxImageSize: 8 * 1024, // 只转8kb以下的图片为base64 }) ) .pipe(concat('main.min.css')) .pipe(cssnano()) .pipe(gulp.dest('./dist/assets/css')) ) } gulp.task('css:dev', async () => { await cssMin().pipe(connect.reload()) }) gulp.task('css:build', async () => { await cssMin() }) /* JS：合并压缩 * ------------------------------------------------------ */ const jsMin = () => { return gulp .src('./src/assets/js/*.js') .pipe(preprocess({ context: { NODE_ENV: 'production' } })) .pipe(concat('main.min.js')) .pipe( uglify().on('error', function (err) { gutil.log(gutil.colors.red('[Error]'), err.toString()) this.emit('end') }) ) .pipe(gulp.dest('./dist/assets/js')) } const jsMinDev = () => { return gulp .src('./src/assets/js/*.js') .pipe(preprocess({ context: { NODE_ENV: 'development' } })) .pipe(concat('main.min.js')) .pipe( uglify().on('error', function (err) { gutil.log(gutil.colors.red('[Error]'), err.toString()) this.emit('end') }) ) .pipe(gulp.dest('./dist/assets/js')) } gulp.task('js:dev', async () => { await jsMinDev().pipe(connect.reload()) }) gulp.task('js:build', async () => { await jsMin() }) /* IMAGE：压缩 * ------------------------------------------------------ */ const imageMin = () => { return gulp .src(['./src/assets/img/*.png', './src/assets/img/*.jpg']) .pipe(cache(imagemin({ progressive: true, use: [pngquant()] }))) .pipe(gulp.dest('./dist/assets/img')) } // 合并sprite图 const spriteData = () => { return gulp .src('./src/assets/img/sprite/*.png') .pipe( spritesmith({ imgName: 'img/sprite.png', cssName: 'css/sprite.css', cssFormat: 'css', padding: 10, }) ) .pipe(gulp.dest('./dist/assets')) } gulp.task('image:dev', async () => { await imageMin().pipe(connect.reload()) await spriteData().pipe(connect.reload()) }) gulp.task('image:build', async () => { await imageMin() await spriteData() }) /* DEV：开发环境执行对应的开发任务 * ------------------------------------------------------ */ // 监听源文件变化 gulp.task('watch', () => { gulp.watch('./src/assets/css/*.css', gulp.series('css:dev')) gulp.watch('./src/assets/js/*.js', gulp.series('js:dev')) gulp.watch(['./src/assets/img/*.png', './src/assets/img/*.jpg'], gulp.series('image:dev')) gulp.watch('./src/**/*.html', gulp.series('html:dev')) }) // 启动服务 // visit localhost:3000 gulp.task('server', () => { connect.server({ root: './dist', // 以根目录作为入口 port: 3000, livereload: true, }) }) const gulpdev = () => { return gulp.series(gulp.parallel('watch', 'server')) } gulp.task('dev', gulp.series(gulp.parallel('watch', 'server'))) /* BUILD：生产环境执行对应的构建任务 * ------------------------------------------------------ */ gulp.task('build', gulp.series('clean', gulp.parallel('html:build', 'js:build', 'image:build', 'css:build'))) /* TEST：测试环境执行对应的构建任务 * ------------------------------------------------------ */ gulp.task('test', gulp.series('clean', gulp.parallel('html:build', 'js:dev', 'image:build', 'css:build'))) Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "},"项目工程化/版本发布规范.html":{"url":"项目工程化/版本发布规范.html","title":"版本发布规范","keywords":"","body":"自动版本化和生成 CHANGELOG 工具 standard-version: include lifecycle steps（bump, changelog, commit, tag） 自动修改 package.json 的 version 生成 changlog 提交当前记录 打 git tag 安装 # 安装standard-version $ pnpm add -D standard-version # Add an npm run script to your package.json $ npm set-script release \"standard-version\" 使用 # –release-as, -r 指定版本号 # 示例 version = v1.0.0 # 万能 $ npm release -r x.x.x # v2.0.0 $ npm release -r major # v1.1.0 $ npm release -r minor # v1.0.1 $ npm release -r patch # v1.0.1-0 $ npm release -r prepatch 跳过某些步骤： package.json { \"standard-version\": { \"skip\": { \"changelog\": true } } } 版本管理与发布 git tag 语义化版本三段式：主版本（major）.次版本（minor）.修订版（patch），如 v1.2.1 修改主版本：架构升级或架构重大调整，不兼容的 API 修改 修改次版本：新功能上线或者模块大的调整，向下兼容的功能性新增 修改修订版：bug 修复上线，向下兼容的问题修正 其他定义，比如：1.2.0-beta.1，1.0.1-alpha.1，3.0.0-rc.1 内部测试版 alpha：一般不向外部发布,会有很多 Bug.一般只有测试人员使用 测试版 beta：这个阶段的版本会一直加入新的功能，在 alpha 版之后推出 最终测试版本 rc(Release Candidate)：可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本 git tag version // 打 tag git tag -a -m // 打详细的 tag git push origin v1.5 // 推送某一tag git push origin --tags // 推送本地所有 tag git tag -d v1.1.1 // 删除本地 tag npm tag npm 的 tag 有这几种类型： latest：最后版本，npm install 的就是这个 beta：测试版本，一般内测使用，需要指定版本号 install，例如 3.1.0-beta.0 next: 先行版本，npm install foo@next 安装，例如 3.0.2-alpha.0 npm dist-tag ls [] // 查看包的tag npm publish --tag beta // 发布测试版本包 npm dist-tag add my-package@1.0.1-beta.0 beta // 修改已发布的包类型为测试 npm dist-tag add my-package@1.0.0 latest // 修改已发布的包类型为最后版本 npm publish npm 注册账号 npm 设置源为：www.npmjs.com/ 终端 npm login package.json 配置 versions,files,main,private,keywords....，其中 versions 每次发布都得更新；files 写需要打包的文件，优先级高于 .npmignore 和 .gitignore，支持通配符； npm publish 查看 npm 打包内容： npm publish --dry-run npm pack 设置要发布的地址： \"publishConfig\": { \"registry\": \"http://registry.npm.xxx.com/\" } 其他参考 git commit 、CHANGELOG 和版本发布的标准自动化 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 22:12:52 "}}