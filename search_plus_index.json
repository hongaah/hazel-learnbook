{"./":{"url":"./","title":"Introduction","keywords":"","body":"hazel-learnbook 🌈 Introduction My personal front-end learning record SUMMARY 前端工具 Fetch Html 2 Canvas h函数 Postmessage Tsx Vite 技术优化 node内存溢出 vue-cli3.x项目webpack优化 Web Worker 跨端方案 Apicloud Electron Flutter Uni App Uniapp 通用工具 Curl Gitbook 网络抓包Charles 项目工程化 Github Action Monorepo Qiankun Rollup Pack Node Vite Pack Node 代码提交规范 代码校验 代码格式化 无框架项目gulp篇 模块联邦Module-Federation 版本发布规范 🔗 Powered by Gitbook # install $ npm install -g gitbook-cli # usage with nvm ✨ Gitbook Features GitBook GitBook Plugins generate a SUMMARY.MD via Gitbook Summary Automated deployment via Github Actions choose /docs via Github Pages Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 17:35:05 "},"前端工具/fetch.html":{"url":"前端工具/fetch.html","title":"Fetch","keywords":"","body":"fetch features fetch() 的功能与 XMLHttpRequest 基本相同，但有三个主要的差异 promise 模块化设计，API 分散在多个对象上（Response、Request、Headers） 数据流（stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内容占用；XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来 请求是否成功标识（只有网络错误，或者无法连接时，fetch() 才会报错，其他情况都不会报错，而是认为请求成功） 捕获错误 try catch 模块化对象 Response 对象 fetch() 请求成功以后，得到的是一个 Response 对象，response 是一个 Stream 对象。 const response = await fetch(url) // 同步属性 console.log('response.ok', response.ok) // 返回一个布尔值，表示请求是否成功，true对应 HTTP 请求的状态码 200 到 299，false对应其他的状态码 console.log('response.status', response.status) // 回一个数字，表示 HTTP 回应的状态码 console.log('response.statusText', response.statusText) // 返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回\"OK\"） console.log('response.url', response.url) // 返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL console.log('response.type', response.type) // 返回请求的类型 console.log('response.redirected', response.redirected) // 返回一个布尔值，表示请求是否发生过跳转 // 异步方法 // Response对象根据服务器返回的不同类型的数据，提供了不同的读取方法。 await response.text() // 得到文本字符串，比如 HTML 文件。 await response.json() // 得到 JSON 对象。 await response.blob() // 得到二进制 Blob 对象，比如图片文件。 await response.formData() // 得到 FormData 表单对象，主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。 await response.arrayBuffer() // 得到二进制 ArrayBuffer 对象，比如音频文件。 // Stream 对象只能读取一次，读取完就没了，再读取会报错，可以通过创建Response对象的副本，实现多次读取。 const response2 = response.clone() Headers 对象 Response 对象还有一个 Response.headers 属性，指向一个 Headers 对象，对应 HTTP 回应的所有标头。 const headers = response.headers Headers.get() // 根据指定的键名，返回键值。 Headers.has() // 返回一个布尔值，表示是否包含某个标头。 Headers.set() // 将指定的键名设置为新的键值，如果该键名不存在则会添加。 Headers.append() // 添加标头。 Headers.delete() // 删除标头。 Headers.keys() // 返回一个遍历器，可以依次遍历所有键名。 Headers.values() // 返回一个遍历器，可以依次遍历所有键值。 Headers.entries() // 返回一个遍历器，可以依次遍历所有键值对（[key, value]）。 Headers.forEach() // 依次遍历标头，每个标头都会执行一次参数函数。 ReadableStream 对象 Response 对象有一个 Response.body.getReader() 属性，指向一个 ReadableStream 对象，可以用来分块读取内容，应用之一就是显示下载的进度 const response = await fetch('flower.jpg') const reader = response.body.getReader() // 返回一个遍历器。这个遍历器的read()方法每次返回一个对象，表示本次读取的内容块。 while(true) { // done属性是一个布尔值，用来判断有没有读完；value属性是一个 arrayBuffer 数组，表示内容块的内容，而value.length属性是当前块的大小。 const {done, value} = await reader.read() if (done) { break } console.log(`Received ${value.length} bytes`) } AbortController 对象 取消 fetch() 请求需要使用 AbortController 对象 // const controller = new AbortController() const signal = controller.signal const postreq = await fetch(getContentByTypeCodeUrl, { method: 'post', headers: { 'Content-Type': 'application/json;charset=utf-8' }, body: JSON.stringify({ platformSource: 0, typeCode: 'orderMust' }) signal: signal // 指定一个 AbortSignal 实例，用于取消fetch()请求 }) signal.addEventListener('abort', (e) => { console.log('abort', e) }) // 用于取消 fetch 请求 setTimeout(() => { controller.abort() }, 2000) 请求数据类型 let params = {} const response = await fetch('xxx', { method: 'POST', body: params }) 提交 JSON 数据 params = JSON.stringify(user) 提交表单 const form = document.querySelector('form') params = new FormData(form) 文件上传 const input = document.querySelector('input[type=\"file\"]') const data = new FormData() data.append('file', input.files[0]) data.append('user', 'foo') params = data 直接上传二进制数据 let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png') ) params = blob get 请求的参数转对象传递 直接传：❎ Failed to execute 'fetch' on 'Window': Request with GET/HEAD method cannot have body 借助 Qs：✅ const params = { path: url, color: 128, level: 9 } fetch(`/sharp-compress-gif/compression?${Qs.stringify(params)}`, { method: 'GET', }) usage Fetch API 教程 try { /** GET 请求 */ // fetch() 接收到的 response 是一个 Stream 对象 const response = await fetch(queryCouponConfigListUrl) const resData = await response.json() /** POST 请求 */ const postreq = await fetch(getContentByTypeCodeUrl, { method: 'post', headers: { 'Content-Type': 'application/json;charset=utf-8' }, body: JSON.stringify({ platformSource: 0, typeCode: 'orderMust' }), referrer: 'about:client', referrerPolicy: 'no-referrer-when-downgrade', mode: 'cors', // 允许跨域请求 credentials: 'same-origin', // 同源请求时发送 Cookie，跨域请求时不发送 cache: 'default', // 先在缓存里面寻找匹配的请求 redirect: 'follow', // fetch()跟随 HTTP 跳转 integrity: '', // 指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。 keepalive: true, // 该属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据 signal: signal // 指定一个 AbortSignal 实例，用于取消fetch()请求 }) const postresult = await postreq.json() console.log('result', postresult) } catch (e) { console.log('error', e) } Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"前端工具/html2canvas.html":{"url":"前端工具/html2canvas.html","title":"Html 2 Canvas","keywords":"","body":"html2canvas 读取已经渲染好的 DOM 元素的结构和样式信息，然后基于这些信息去构建截图，呈现在 canvas 画布中。 使用场景 生成 canvas 下载图片 页面截图打印 安装 npm i html2canvas 使用 ... 下载 import html2canvas from 'html2canvas' download() { html2canvas(document.querySelector('#banner'), { useCORS: true, // 是否尝试使用CORS从服务器加载图像 allowTaint: false, // 是否允许跨域图像污染画布 scale: 4, // 放大倍数 提高图片质量 width: dom.offsetWidth, // 直接取得需要转为图片的dom元素的宽高 height: dom.offsetHeight, }).then(canvas => { // 去除锯齿 let context = canvas.getContext('2d') context.mozImageSmoothingEnabled = false context.webkitImageSmoothingEnabled = false context.msImageSmoothingEnabled = false context.imageSmoothingEnabled = false // 加载动画 this.posterLoading = Loading.service({ lock: true, text: '下载海报中……', background: 'rgba(0, 0, 0, 0.5)', }) let self = this let url = canvas.toDataURL() let xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.responseType = 'blob' xhr.onload = function () { if (this.status === 200) { let blob = this.response let fileName = self.posterTitle.includes('.') ? self.posterTitle + '.png' : self.posterTitle if (navigator.msSaveBlob == null) { const link = document.createElement('a') const event = new MouseEvent('click') link.download = fileName link.href = URL.createObjectURL(blob) link.dispatchEvent(event) } else { navigator.msSaveBlob(blob, fileName) } } setTimeout(() => { self.posterLoading.close() }, 200) } xhr.send() // 模拟下载 const link = document.createElement('a') const event = new MouseEvent('click') link.download = this.activityTitle link.href = canvas.toDataURL() link.dispatchEvent(event) }) }, 分辨率 scale： scalewindow.devicePixelRatio 用于渲染的缩放比例，默认为浏览器设备像素比 问题 图片不显示 可能原因： html2canvas 没有配置 useCORS: true // 是否尝试使用 CORS 从服务器加载图像 后台没有配置跨域 后台配置跨域了但控制台还是显示跨域错误 原因： 浏览器本地缓存错误，即重复请求了相同的接口，导致跨域错误。 因为 html2canvas 只会根据 dom 结果请求并且对图片来源有限制。当 dom 有图片就会请求网络，所以 canvas 第二次请求实际上是从缓存获取，如果从缓存读取类似本地读取照片则会有跨域限制。 验证： 开启控制台网络的禁止缓存选项 解决： 加 cdn，但要加钱 配置 CORS 规则，附加相关 Header，选中返回 vary: origin 头以避免本地缓存错乱。但是选中后可能会造成浏览器访问次数或 CDN 回源次数增加。 样式错乱，与网页不一 部分 css 样式不兼容，比如 clac 计算样式等等 下载不了或无反应 可能性： 需要在页面渲染完毕再下载 报错 TypeError: Failed to execute 'addColorStop' on 'CanvasGradient' 可能性： 页面渲染后存在两个相同 canvasId 的 canvas 参考 html2canvas 实现浏览器截图的原理（包含源码分析的通用方法） html2canvas 兼容性 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"前端工具/h函数.html":{"url":"前端工具/h函数.html","title":"h函数","keywords":"","body":"h 函数 概述 Vue 提供了一个 h() 函数用于创建虚拟节点（vnodes）。h() 是 hyperscript 的简称，意思是\"能生成 HTML (超文本标记语言) 的 JavaScript\"。这个名字来源于许多虚拟 DOM 实现默认形成的约定。虽然一个更准确的名称应该是 createVNode()，但在需要频繁使用渲染函数时，简短的名字更具优势。 核心特点 高度灵活性：h() 函数可以适应各种组件和元素创建需求 多种参数格式： 支持对象形式编写 属性可以写成驼峰式或 kebab-case 格式（使用引号包裹） 事件监听器可以写成 onClick 形式或对象形式 详细用法示例 h('div', null, [ h( 'div', { // 样式对象（驼峰式） style: { marginTop: '10px', backgroundColor: '#f5f5f5' }, // DOM 属性 props: { value: someValue, id: 'container' }, // 事件监听器 on: { input: (value) => { this.value = value }, change: (value) => { handleChange(value) }, // 也可以使用 kebab-case 格式 'custom-event': handleCustomEvent }, // 其他特殊属性 attrs: { 'data-test': 'test-id' }, // 类名 class: { 'active': isActive, 'disabled': isDisabled } }, { // 插槽内容必须使用函数形式 default: () => [ '审核建议：', h(ElInput, { // 双向绑定 modelValue: var1.value, 'onUpdate:modelValue': (val: string) => { var1.value = val }, // 其他属性 placeholder: '请输入', type: 'textarea', minRows: 4, maxlength: 1000, showWordLimit: true, // 原生事件 onClick: handleClick, // 自定义指令 directives: [ { name: 'focus', value: true } ] }) ] } ) ]) 插槽处理最佳实践 常见错误：\"Non-function value encountered for default slot.\" 性能优化：Vue 3 推荐使用函数式插槽以获得更好的性能 显式声明：即使只是默认插槽，也需要显式写出 default: () => ... 的形式 多插槽处理：当组件有多个插槽时，需要为每个插槽提供函数 // 错误写法 - 直接传递内容 return h(Component, { props }, content) // 正确写法 - 默认插槽 return h(Component, { props }, { default: () => content }) // 多个插槽 return h(Component, { props }, { default: () => [content1, content2], header: () => h('div', 'Header'), footer: () => h('div', 'Footer') }) 进阶技巧 动态组件： h(resolveComponent(componentName), { ...props }) 递归组件： h('div', { key: node.id }, [ node.children ? node.children.map(child => h(recursiveComponent, { node: child })) : null ]) JSX 替代： const vnode = Hello 指令使用： h('div', { directives: [ { name: 'my-directive', value: someValue, arg: 'arg', modifiers: { modifier: true } } ] }) 性能优化 避免不必要的重新渲染：为列表项提供稳定的 key 合理使用函数式组件：对于无状态的展示组件 缓存静态内容：将不变化的 vnodes 缓存起来 合理使用片段：减少不必要的包装元素 版本差异说明 Vue 2 vs Vue 3： Vue 2 使用 createElement 而非 h Vue 3 的插槽必须使用函数形式 Vue 3 对属性处理更加严格 Composition API： import { h } from 'vue' export default { setup() { return () => h('div', 'Hello') } } Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 17:12:52 "},"前端工具/postmessage.html":{"url":"前端工具/postmessage.html","title":"Postmessage","keywords":"","body":"postMessage 跨窗口通信 1.父窗口给子窗口发送消息的方式： iFrame.contentWindow.postMessage('MessageFromIndex1','_'); 其实就是在父窗口中操作子窗口发消息，然后让子窗口接收自己刚才发的消息。 2.子窗口给父窗口发送消息的方式： parent.postMessage({msg: 'MessageFromIframePage'}, '_'); 注意：此处 parent === window.parent，即子窗口的父窗口。 其实就是在子窗口中操作父窗口发消息，然后让父窗口接收自己刚才发的消息。 总结：所谓的跨窗口发送消息，就是通过在别的窗口操作本窗口发送消息，然后本窗口再自己接收的方式实现。 // 子页面 // 子窗口传父 function sendMessage() { // top = window.parent = window.top top?.postMessage( { data: { code: 'success', text: '子頁面的test', }, }, '*' ) } // 子窗口接收父 const result = ref({}) window.addEventListener( 'message', (event: any) => { result.value = event.data.data }, false ) // 父窗口 // 父接收子 const result = ref() onMounted(() => { window.addEventListener('message', (event: any) => { const data = event.data.data if (data?.code === 'success') { ElMessage(data?.text) result.value = data?.text } }) // 父发子先定义 myFrameInstance.value = myFrameRef.value?.contentWindow }) // 父发子 const myFrameRef = ref() const myFrameInstance = ref() function sendMessage() { myFrameInstance.value.postMessage( { data: 'Hello Message From Bi!', }, '*' ) } 可参考库：https://github.com/dollarshaveclub/postmate window.top.postmessage 和 window.postmessage window.top.postmessage 才能传值 window.top.postMessage({ name: 'test' }, '*') 多窗口嵌套传值 const sendData = {} const windowList = [] function getWindow (currentWindow) { if (currentWindow.top.opener) { // 多窗口层级 if (currentWindow.top.vm) { // 新后台 return currentWindow.top } else { windowList.push(currentWindow.top) return getWindow(currentWindow.top.opener) } } else { // 只有一个层级 return currentWindow.top } } function closeWindows() { windowList.forEach(item => { if (item === window) { setTimeout(() => { item.close() }, 1) } else { item.close() } }) } getWindow(window).postMessage(sendData, '*') closeWindows() window.opener.xx 父：window.xx = () => {} 子： window.opener.xx() widnow.close() MessageChannel https://www.jianshu.com/p/4f07ef18b5d7 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"前端工具/tsx.html":{"url":"前端工具/tsx.html","title":"Tsx","keywords":"","body":"tsx SFC：Vue 单文件组件 TSX：TypeScript 文件，包含 JavaScript XML（JSX） 配置 vite.config.ts // pnpm install @vitejs/plugin-vue-jsx -D import { defineConfig } from \"vite\" import vue from \"@vitejs/plugin-vue\" import vueJsx from \"@vitejs/plugin-vue-jsx\" export default defineConfig({ plugins: [ vue(), vueJsx() //插件使用 ], css: { modules: { // 规定css类名的命名规则为小驼峰，即 child-item css 类在 js 中会变成 childItem 变量 localsConvention: 'camelCase' } }, }) CSS Modules css module 把 css 作为模块引入到 js 中，是一种技术流的组织css代码的策略，它将为css提供默认的局部作用域。 css module 对 css 文件命名有要求，必须在后缀名前面是module，例如xxx.module.css、xxx.module.less、xxx.module.scss。 vite.config.ts css: { modules: { // 规定css类名的命名规则为小驼峰，即 child-item css 类在 js 中会变成 childItem 变量 localsConvention: 'camelCase' } }, const TsxDemo = defineComponent({ setup() { return () => { return ( <> {/* OR */} ) } }, }) export default TsxDemo 编译和使用 css module 会在编译的时候自动把类名加上一个哈希字符串，而使用 global 声明的 class 不会在编译的时候被加上哈希字符串。 index.module.scss /** 形式一 */ .demo-normal { .normal-test { background-color: red !important; } } // 形式一会编译成： ._react-demo_1e21d_6 ._demo-test_1e21d_6 { background-color: red !important; } /** 形式二 */ .demo-global { :global { .global-test { background-color: red !important; } } } // 形式二会编译成： ._react-demo_86lo7_6 .demo-test { background-color: red !important; } 类名使用引用的方式会被编译成哈希字符串的，global 声明则不能用引用的方式。 // 形式一 normal // 形式二 global global 全局作用选择器 statistics.module.scss // react，如果我们想要覆盖第三方的组件样式，用自己写的选择器名称是覆盖不了的，因为加了哈希字符串之后与组件默认样式的选择器名称不匹配；而使用 global 声明的 class，不会在编译的时候被加上哈希字符串，从而可以实现覆盖默认样式的效果。 .table-wrap { :global { .el-table td.el-table__cell, .el-table thead.is-group th.el-table__cell { padding: 5px !important; } } } // 区别 vue，即使用一个唯一的类名包着也会作用到有用到该类名的全局样式，慎用 // 比如在下方例子中，其他文件用了 .test 类名也会被影响到 .notice-dialog { :global(.el-dialog.is-fullscreen) { min-width: 900px !important; } :global(.test) { background-color: red !important; } } classnames classNames('foo', 'bar') // => 'foo bar' Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 12:11:32 "},"前端工具/vite.html":{"url":"前端工具/vite.html","title":"Vite","keywords":"","body":"Vite 原理 1. 开发服务器启动阶段 与传统工具的本质区别： Webpack等传统工具：必须完整打包所有模块才能启动开发服务器 Vite：立即启动服务器，仅准备最基础运行时环境（如 vite/client 热更新逻辑） 启动流程： 初始化HTTP服务器（约50ms） 扫描项目入口文件（index.html） 建立模块依赖图的骨架结构（不解析具体内容） 实现效果：无论项目大小，启动时间恒定在100-300ms 冷启动优势： 传统工具：O(n)复杂度（n=模块数量） Vite：O(1)复杂度 2. 浏览器请求处理阶段 原生ES模块的工作流程： 浏览器请求 index.html ↓ HTML中遇到 ↓ 浏览器发起对main.js的请求 ↓ Vite实时转换JS文件（如TS→JS、Vue SFC编译） ↓ 返回转换后代码，其中包含import语句 ↓ 浏览器继续发起对依赖模块的请求（循环此过程） 关键优化点： 按需编译：只编译当前页面实际用到的文件 依赖预构建：将CommonJS模块转换为ESM格式（存储在node_modules/.vite） 强缓存：未修改的源码返回304状态码 浏览器协作：利用浏览器原生模块解析能力，将部分工作转移给性能更强的现代浏览器，开发服务器只需做轻量级转换 3. 热更新（HMR）机制 对比传统方案： Webpack和Vite在更新范围、更新时间和通信方式上存在显著差异。 Webpack需要更新整个bundle，其更新时间会随着项目规模线性增长；而Vite只需更新单个文件，更新时间恒定在50毫秒以内。在通信方式方面，Webpack使用WebSocket，Vite则结合了WebSocket和ETag技术。 具体执行流程： 文件修改触发文件系统监听 Vite确定受影响模块范围 通过WebSocket发送更新消息（包含新模块内容） 浏览器直接替换ES模块实例 // 传统工具需要重建整个依赖图 function rebuild() { const fullDependencyGraph = buildGraph(); return bundle(fullDependencyGraph); } // Vite只需处理变更文件 function rebuild(file) { const affected = getAffectedModules(file); return partialUpdate(affected); } 4. 生产构建策略 开发与生产环境差异： graph LR A[开发环境] -->|基于ESM| B[按需编译] C[生产环境] -->|基于Rollup| D[全量打包] D --> E[代码分割] D --> F[Tree-shaking] D --> G[资源压缩] Rollup打包的优势： 更高效的tree-shaking（相比webpack） 更简洁的bundle输出 更好的代码分割控制 构建 vite.config.ts export default defineConfig({ base: '/project/', server: { port: 3000, open: true }, build: { outDir: 'dist', assetsInlineLimit: 4096 } }) package.json \"scripts\": { \"dev\": \"vite\", \"build\": \"tsc && vite build -w\" } 开发模式 (pnpm dev) 服务器启动流程： 解析项目配置（vite.config.ts） 创建模块依赖图（Module Graph） 启动 HTTP 服务器和 WebSocket 服务（用于 HMR） 请求处理机制： sequenceDiagram 浏览器->>Vite 服务器: 请求 index.html Vite 服务器->>浏览器: 返回原始 HTML 浏览器->>Vite 服务器: 请求 main.js Vite 服务器->>浏览器: 返回转换后的 JS 浏览器->>Vite 服务器: 请求依赖模块 Vite 服务器->>浏览器: 按需返回模块 缓存策略： 预构建依赖（node_modules）会被缓存到 node_modules/.vite 源码文件使用强缓存（Cache-Control: max-age=31536000） 修改文件后通过 WebSocket 通知浏览器失效缓存 生产构建 (pnpm build) 构建过程： 使用 Rollup 进行打包 自动应用 tree-shaking 移除未使用代码 支持多种输出格式（ESM、IIFE、UMD） 构建完成后，public 目录下的内容会被复制到输出目录中 代码分割策略： 动态导入（import()）自动创建单独 chunk 支持手动配置 manualChunks 优化分包 CSS 自动提取到单独文件 性能优化： 使用 esbuild 进行最小化（比 Terser 快 20-40 倍） Brotli/Gzip 压缩支持 支持异步 chunk 加载优化 监听模式： 默认情况下，构建完成后不会持续监听文件变化 添加 -w 参数（pnpm build -w）会启用持续监听并自动重新构建 环境变量 vite build 默认运行生产模式构建，也可以通过使用不同的模式和对应的 .env 文件配置来改变它，用以运行开发模式的构建。 import.meta.env.DEV: 是否运行在开发环境(NODE_ENV=development) import.meta.env.PROD: 是否运行在生产环境(NODE_ENV=production) 模式扩展： // vite.config.js export default defineConfig({ define: { __APP_VERSION__: JSON.stringify(process.env.npm_package_version) } }) 智能类型提示： 创建 src/env.d.ts 获得类型提示： interface ImportMetaEnv { readonly VITE_API_URL: string readonly DEV: boolean readonly PROD: boolean } 环境变量转换： 只有 VITE_ 前缀的变量会暴露给客户端 使用 dotenv-expand 支持变量扩展 支持 .env.local 覆盖机制 Rollup 代码分割 分包策略进阶 自动分包算法： function autoChunk(id) { if (id.includes('node_modules')) { return 'vendor' } if (id.includes('src/utils')) { return 'utils' } } 依赖分析优化： 使用 rollup-plugin-visualizer 分析包大小 通过 getModuleInfo 获取模块引用关系 动态调整 chunk 分割阈值 解决循环依赖： function stableChunk(id, { getModuleInfo }) { const moduleInfo = getModuleInfo(id) if (moduleInfo.importers.some(imp => imp.isEntry)) { return 'main' } } 常见问题解决方案 Chunk 碎片问题： 设置最小 chunk 大小阈值（如 10KB） 合并常用工具函数到共享 chunk 使用 rollupOptions.output.minChunkSize 配置 循环引用报错： manualChunks(id, { getModuleInfo }) { if (id.includes('react')) return 'react' if (id.includes('lodash')) return 'lodash' } 动态导入优化： // 使用 /* webpackChunkName: \"name\" */ 注释 import(/* webpackChunkName: \"chart\" */ './chart') 性能优化 开发环境提速 依赖预构建： 首次启动时自动执行 将 CJS 模块转换为 ESM 合并多个小文件减少请求 配置优化： export default defineConfig({ optimizeDeps: { include: ['lodash-es', 'axios'] } }) 冷启动问题： 使用 vite-plugin-optimize-persist 持久化优化 预配置常用依赖 生产环境优化 异步加载优化： // vite.config.js export default defineConfig({ build: { rollupOptions: { output: { manualChunks: { 'react-vendor': ['react', 'react-dom'], 'chart': ['echarts'] } } } } }) 资源内联： CDN 加速： export default defineConfig({ build: { rollupOptions: { external: ['react'], output: { globals: { react: 'React' } } } } }) Vite 3 → 4 版本迁移 升级步骤： vite 安装 4 后，执行 pnpm i 查看相对应的 peer 依赖应该是多少。 联动 peer 依赖更新，比如：vitejs/plugin-vue vitejs/plugin-vue-jsx unplugin-icons unplugins-element-plus 测试页面 可以解决： 开发环境页面加载问题慢 出现的问题： element-ui 下拉框组件出现异常，与 ui 版本有关。 element-plus el-select updateOptions emit 报错：[Vue warn]: Extraneous non-emits event listeners (updatedcount) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option 目前解决：将 element-plus 降级到没有 updateOptions emit 即 2.2.32 恢复正常。还原相同环境测试 vue 相关的 emit 无问题，应该是 element-plus 问题，具体问题待确定。 // 临时解决方案 import { ElSelect } from 'element-plus' delete ElSelect.emits 常见问题排查 HMR 失效： 检查 WebSocket 连接状态 验证文件系统事件是否触发 确保没有浏览器扩展干扰 构建性能分析： vite build --profile 依赖解析问题： export default defineConfig({ resolve: { alias: { '@': path.resolve(__dirname, 'src') } } }) Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 17:14:46 "},"技术优化/node内存溢出.html":{"url":"技术优化/node内存溢出.html","title":"node内存溢出","keywords":"","body":"node 内存溢出问题 Node 进程的内存限制是有限的，当前在默认情况下，V8 在 32 位系统上的内存限制为 512mb，在 64 位系统上的内存限制为 1gb，所以有些项目在加了 Babel 后在构建时可能会出现内存溢出的问题。可以通过将 --max-old-space-size 的值提高，但是如果达到内存限制，还可以将单个进程拆分为多个工作进程。 解决方法 windows 方式一：VSCode 工作区设置 .vscode/settings.json { \"terminal.integrated.env.windows\": { \"node_options\": \"--max_old_space_size=3072\" } } 方式二：在 package.json 中设置 package.json \"scripts\": { \"serve\": \"vue-cli-service serve --max_old_space_size=3072\", } 方式三：在终端进程中设置 set NODE_OPTIONS=--max-old-space-size= // 单开终端 export NODE_OPTIONS=\"--max-old-space-size=8192\" // 永久终端 macos macos 在.bash_profile 下加入 export NODE_OPTIONS=--max_old_space_size=3072 https://www.cnblogs.com/caofeng11/p/13160416.html windows 和 macos 通用的方式，使用 cross-env 跨平台设置环境变量 npm install -D cross-env \"scripts\": { \"serve\": \"cross-env NODE_OPTIONS=--max_old_space_size=3072 vue-cli-service serve\", }, https://blog.csdn.net/wuyujin1997/article/details/122869951 更多可参考： 详细配置 nodejs 设置应用的内存上限 NODE_OPTIONS=--max-old-space-size=8192 node 内存溢出了？ 看看这篇。 其他 Node.js heap out of memory 升级 node 版本 运行以下命令 npm install -g increase-memory-limit increase-memory-limit https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"技术优化/vue-cli3.x项目webpack优化.html":{"url":"技术优化/vue-cli3.x项目webpack优化.html","title":"vue-cli3.x项目webpack优化","keywords":"","body":"vue-cli3.x 项目 webpack 优化 terser-webpack-plugin 该插件可以压缩 JavaScrip 和在构建时一键去掉调试打印语句 安装： $ npm install terser-webpack-plugin@3.1.0 --save-dev 配置： vue.config.js const TerserPlugin = require('terser-webpack-plugin') configureWebpack: config => { if (process.env.NODE_ENV === 'production') { return { optimization: { minimize: true, minimizer: [ new TerserPlugin({ cache: true, parallel: true, sourceMap: false, terserOptions: { compress: { drop_console: true, drop_debugger: true, // pure_funcs: ['console.log'], // 移除console }, }, }), ], }, } } 参考链接： https://v4.webpack.docschina.org/configuration/optimization/#optimization-minimizer https://github.com/webpack-contrib/terser-webpack-plugin https://github.com/terser/terser#minify-options compression-webpack-plugin 压缩静态资源，服务端在 Nginx 开启 Gzip 属性。Nginx 在访问资源时，如果该资源有 gz 文件，则会请求 gz 文件。 安装： $ npm install compression-webpack-plugin --save-dev 配置： vue.config.js const CompressionPlugin = require('compression-webpack-plugin') // 引入gzip configureWebpack: config => { if (process.env.NODE_ENV === 'production') { return { plugins: [ // 添加gzip new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, threshold: 10240, deleteOriginalAssets: false }), ] } } 参考： https://v4.webpack.js.org/plugins/compression-webpack-plugin/ 分析打包速度 speed-measure-webpack-plugin https://github.com/stephencookdev/speed-measure-webpack-plugin 只针对 plugins Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"技术优化/web-worker.html":{"url":"技术优化/web-worker.html","title":"Web Worker","keywords":"","body":"webworker 一个独立于 JavaScript 主线程的独立线程，在里面执行需要消耗大量资源的操作不会堵塞主线程。 JavaScript 是单线程的语言，如果在浏览器中需要执行一些大数据量的计算，页面上的其他操作就会因为来不及响应而出现卡顿的情况，Web Worker 的出现为 js 提供了一个多线程的环境，让更多复杂计算拿到另一个环境中去完成，计算完之后再提供给主进程使用，前端页面可以只负责界面渲染，让用户体验更流畅。 Web Worker 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。 Web Worker 在处理一些复杂的计算或耗时的任务时非常有用，可以提高网页的性能和响应能力。然而，它并不适用于所有情况，需要根据具体的应用场景和需求来决定是否使用 Web Worker。 web workers 已经被大多数浏览器支持，使用上基本不用考虑兼容问题。 使用限制 同源限制 接口限制（由于 Web Worker 运行在独立的线程中，它无法直接访问主线程的 DOM、全局变量和大多数浏览器 API。window 作用域下的部分方法不可使用，如 DOM 对象、window.alert 和 window.confirm 等方法。） 文件限制（无法加载本地 js 文件，必须使用线上地址。） 记得关闭（worker 会占用一定的系统资源，在相关的功能执行完之后，一定要记得关闭 worker，无论是在主线程关闭 worker，还是在 worker 线程内部关闭 worker，worker 线程当前的 Event Loop 中的任务会继续执行。至于 worker 线程下一个 Event Loop 中的任务，则会被直接忽略，不会继续执行。但是在主线程关闭则通信会被关闭，不会再接收到信息，worker 线程关闭则会在当前 Event Loop 中接收） 使用时注意 this 指向 webworker 的使用 通过 postMessage 实现主线程和 Web Worker 双向通信 关键代码： const worker = new Worker('xx url') worker.onmessage = (e) => {e.data} worker.postMessage('xxx') worker.addEventListener(event: 'error' | 'messageerror', (err) => {}) worker.terminate() self.onmessage = (e) => {e.data} self.postMessage('xxx') self.addEventListener(event: 'error' | 'messageerror', (err) => {}) self.close() import React, { Component } from 'react' import worker_script from './worker-script' export default class PageHome extends Component { constructor(props) { super(props) this.state = {} } componentDidMount() { const worker = new Worker(worker_script) worker.postMessage('dadada') worker.onmessage = function (event) { console.log(`Received message ${event.data}`) // 执行完了以后关闭 webworker // worker.terminate() } } } worker-script.js const workercode = () => { // 在后台执行任务 self.onmessage = function (e) { console.log('Message received from main script') let workerResult = performData(e.data) self.postMessage(workerResult) } function performData(data) { // 执行耗时的某些操作 return `Received from main: ${data}` } } // 在线生成同源线上地址 let code = workercode.toString() code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}')) const blob = new Blob([code], { type: 'application/javascript' }) const worker_script = URL.createObjectURL(blob) export default worker_script @koale/useworker react hooks import React from 'react' import { useWorker } from '@koale/useworker' const numbers = [...Array(5000000)].map(e => ~~(Math.random() * 1000000)) const sortNumbers = nums => nums.sort() const Example = () => { const [sortWorker] = useWorker(sortNumbers) const runSort = async () => { const result = await sortWorker(numbers) // non-blocking UI console.log(result) } return ( Run Sort ) } 参考 https://juejin.cn/post/7139718200177983524 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"跨端方案/":{"url":"跨端方案/","title":"跨端方案","keywords":"","body":"[译] React Native vs. Cordova、PhoneGap、Ionic，等等 原生的定义 软件是关于如何操作大量晶体管和电路 (两者统称为硬件) 的指令的集合。直接运行在硬件上的原始指令对我们人类来说是几乎无法理解的, 特别是考虑到当今计算机的复杂性和规模。 要使得软件可以理解和操作的话，计算机科学家将其划分为多个层，这些层均是由框架构成的，每个框架都运行在另一个框架之上。在所有框架中，越接近硬件的框架，我们就说它更“原生”。 严格来说，我们无法说一个应用本身是否是原生的。我们只能说，相比于另一个应用，它是更原生的。 框架 在 React Native 出现之前，移动端框架一般分为两个阵营。 首先是原生阵营，例如安卓的 Java/Kotlin 和 IOS 的 Objective-C/Swift 。 另外一个阵营就是以 Cordova/PhoneGap 和 Ionic 为代表的 WebView 框架。WebView 框架是在原生框架之上构建的，类似于 web 浏览器，可以同时运行在安卓和 IOS 平台上(还可以有更多平台)。这些框架可以让 Web 开发人员使用他们已经具备的 HTML、CSS 和 JavaScript 技能来开发应用。但是，相比于原生应用，这类应用会没有那么流畅，能访问的硬件功能也有限。 React Native 代表的是移动端框架的第三阵营。React Native 直接运行在原生框架里，它的 UI 层要比 WebView 框架更原生，而其余部分处于模拟层，以实现其易用性。 WebView 框架 基于 HTML5 的跨平台技术比较出名的有 PhoneGap、Cordova，常常用于开发 webapp，还有 Egret、Cocos-creator、Unity、weex、uniapp 等，常用于开发游戏；还有基于 node 的 nw.js，用于开发桌面应用，以及 Electron，一款比 nw.js 还强大的用网页技术来开发桌面应用的神器。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"跨端方案/apicloud.html":{"url":"跨端方案/apicloud.html","title":"Apicloud","keywords":"","body":"apicloud 需付费的可视化低代码开发运营平台 web app 搭建流程 准备工作 手机安装 Apploader，支持 Android & iOS 电脑安装编辑器 APICloud Studio 3，安装好以上两个软件后可用于 APP 开发过程的真机快速调试 在apicloud创建账号 使用 在编辑器登录账号，新建 Native App 项目后即可同步到云控制台，项目中只保留项目中config.xml文件 config.xml 节选部分，关键看以下配置 // 需要跟云项目中id一致 // 链接对入口文件，可以是局域网ip或编译好的项目文件入口 真机调试 以 vue-cli4 项目为例，打包前需修改以下地方： 路由配置为 hash 模式 配置 vue.config.js 文件： publicPath: './' 多页面配置 wifi 同步：链接项目入口后，右键项目根路径打开 WIFI 同步 教程 新手开发指南：https://docs.apicloud.com/APICloud/junior-develop-guide 官方教程：https://www.apicloud.com/video_list#plugins 图文教程：https://juejin.cn/post/6973441944374476831#heading-0 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"跨端方案/electron.html":{"url":"跨端方案/electron.html","title":"Electron","keywords":"","body":"electron 概述 Electron是一个使用 JavaScript、HTML 和 CSS 构建跨平台桌面应用的开源框架。它通过将 Chromium 和 Node.js 合并到同一个运行时环境中，并为操作系统本地功能提供一套丰富的API，使得开发者可以沿用Web技术栈，轻松构建功能强大的桌面应用。 核心概念：主进程与渲染进程 Electron应用的核心架构基于两种进程：主进程（Main Process）和渲染进程（Renderer Process）。 🌰：以 electron 为例： 主进程：每个Electron应用有且仅有一个主进程。它作为应用的入口点，在Node.js环境中运行，负责管理应用的生命周期、创建和管理窗口（BrowserWindow实例）、处理原生操作系统交互（如菜单、对话框、托盘图标等）。主进程是所有渲染进程的父进程，并掌管着系统资源。 在项目中，index.js 就是主进程的脚本。它负责创建应用窗口、处理窗口关闭等事件。 // index.js const { app, BrowserWindow } = require('electron') function createWindow() { const win = new BrowserWindow({ /* ... */ }) win.loadFile('./dist/index.html') // ... } app.on('ready', createWindow) 渲染进程：每个通过BrowserWindow加载的网页都在其自己的渲染进程中运行。渲染进程负责UI的渲染，它运行在Chromium环境中，因此可以使用所有浏览器API，如document、window等。此外，通过Electron的特殊处理，渲染进程也能够访问Node.js模块，这极大地扩展了其能力。 项目中的src/feature/WriteAndRead/index.html及其关联的index.js就运行在渲染进程中。 // 渲染进程可以直接访问DOM const btn = document.getElementById('btn'); btn.onclick = () => { /* ... */ }; Node.js集成：打破浏览器沙箱 Electron最强大的特性之一，就是在渲染进程中无缝集成了Node.js。这意味着，你可以在UI代码中直接调用Node.js的API，例如文件系统（fs）、路径处理（path）等，而无需搭建复杂的后端服务。 在示例中，src/feature/WriteAndRead/index.js就直接使用了Node.js的fs模块来读写本地文件： // src/feature/WriteAndRead/index.js const fs = require('fs'); const path = require('path'); function readFile() { fs.readFile(path.join(__dirname, '/simple.txt'), (err, data) => { // ... }); } 安全提示：在渲染进程中直接使用Node.js能力虽然方便，但也带来了安全风险。如果你的应用需要加载和执行远程网页内容，请务必开启nodeIntegration: false和contextIsolation: true，并通过preload脚本来安全地暴露特定API给渲染进程，以防止恶意代码访问系统资源。 进程间通信（IPC） 虽然主进程和渲染进程各司其职，但它们之间经常需要通信。Electron提供了多种进程间通信（IPC）机制： ipcMain 和 ipcRenderer：这是最常用的一对模块，用于在主进程和渲染进程之间发送和接收异步或同步消息。 remote模块（已废弃）：remote模块提供了一种便捷的方式，可以直接在渲染进程中调用主进程的模块和方法，如同本地对象一样。在项目中就使用了remote模块来创建新窗口： // src/feature/WriteAndRead/index.html const { BrowserWindow } = require('electron').remote; const newWin = new BrowserWindow({ /* ... */ }); 注意：由于性能和安全原因，remote模块在Electron 12之后已被废弃，并计划在未来版本中移除。官方推荐使用ipcMain/ipcRenderer配合contextBridge作为替代方案。 调试 # 开发热更新 $ nodemon --watch . --exec electron . 应用打包与分发 开发完成后，我们需要将应用打包成可执行文件，以便分发给用户。electron-packager是一个流行的打包工具，可以轻松地将Electron应用打包成Windows、macOS和Linux平台的可执行程序。 应用程序的绿色版本：无需安装，拷贝整个文件目录之后即可使用 客户端应用程序安装包：安装之后通过桌面快捷方式的形式去访问（Inno Setup） # 安装electron打包工具electron-packager $ npm install electron-packager -g # 编译绿色安装包 $ electron-packager . appName --win --out ./appName --arch=x64 --app-version=1.0.0 --electron-version=1.0.0 --overwrite --icon=./src/assets/favicon.ico --ignore=node_modules # 客户端应用程序安装包 Inno Setup 通过软件向导生成 setup.exe electron 安装+运行+打包成桌面应用+打包成安装文件+开机自启动 electron-packager electron-packager 的命令结构如下（根据实际情况修改）： .：需要打包的应用目录（即当前目录） appName：应用名称 --win：打包平台（以 Windows 为例） --out ../appName：输出目录 --arch=64：64 位 --app-version=0.0.1：应用版本 --electron-version=2.0.0：项目使用的 electron 版本 electron-packager 编译的安装包跑不起来： 有报错说明代码或调用出问题，会出现在线预览没事，但编译包就出问题 编译包定义的 electron 版本是否与项目用的一致，新版本可支持更多 api 总结与展望 Electron通过巧妙地结合Web技术和原生能力，为开发者打开了构建桌面应用的新大门。理解其主进程与渲染进程的分离架构，善用Node.js集成带来的便利，并掌握进程间通信的技巧，是开发高质量Electron应用的关键。 随着技术的发展，我们应该持续关注Electron的最佳实践，例如使用contextBridge提升应用安全性，以及探索更现代化的打包工具（如electron-builder）来优化分发流程。希望本文能为你探索Electron世界提供一个坚实的起点。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 16:34:46 "},"跨端方案/flutter.html":{"url":"跨端方案/flutter.html","title":"Flutter","keywords":"","body":"Flutter：跨平台 UI 开发框架深度解析 概述 Flutter 是由 Google 开发的开源 UI 软件开发工具包，用于从单一代码库构建跨平台应用程序，支持 iOS、Android、Windows、macOS、Linux 和 Web 平台。Flutter 采用独特的架构设计，使其在性能、开发效率和一致性方面具有显著优势。 核心特点 跨平台一致性：在不同平台上提供像素级一致的 UI 体验 高性能：使用 Skia 图形引擎直接渲染，避免平台原生组件的性能瓶颈 热重载：亚秒级的代码更新反馈循环，极大提升开发效率 丰富的组件库：提供超过 200 个高度可定制的小部件 声明式 UI：采用现代响应式框架构建用户界面 Dart 语言深度解析 Dart 是 Flutter 应用开发的编程语言，是一种适用于客户端和服务器开发的强类型语言。 语言特性 面向对象：支持类、接口、混入(mixin)等面向对象特性 强类型：支持类型推断的静态类型系统 空安全：默认所有类型都是非空的，需显式声明可为空 并发模型：基于隔离(isolate)的并发，避免共享内存带来的复杂性 JIT & AOT 编译：开发时使用 JIT 实现热重载，发布时使用 AOT 获得最佳性能 安装与配置 Windows 平台安装示例 choco install dart-sdk macOS 平台安装示例 brew tap dart-lang/dart brew install dart 环境变量配置 安装完成后，需要将 Dart SDK 的 bin 目录添加到系统 PATH 环境变量中： Windows: C:\\tools\\dart-sdk\\bin macOS/Linux: /usr/local/opt/dart/libexec/bin 编译工具链 dart2js：将 Dart 代码编译为优化的 JavaScript，用于 Web 部署 dart compile js main.dart -o main.js dart2native：将 Dart 代码编译为本地可执行文件 dart compile exe main.dart dartaotruntime：运行预编译的 Dart AOT 快照 与 JavaScript 对比 特性 Dart JavaScript 类型系统 强类型 弱类型 并发模型 Isolate Web Workers 编译方式 JIT & AOT JIT 空安全 默认启用 需TypeScript 开发工具 丰富 丰富 Flutter 开发实践 从 Web 开发转向 Flutter 对于有 Web 开发背景的开发者，以下概念对应关系有助于快速上手： HTML/CSS → Widgets： → Container() → Text() → Image() CSS 样式 → Widget 的属性参数 JavaScript → Dart： Promise → Future async/await → 语法相同 Array.map() → List.map() React/Vue → Flutter： 组件状态管理概念相似 响应式编程范式相通 实际代码示例 基础计数器应用 import 'package:flutter/material.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData(primarySwatch: Colors.blue), home: MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key? key, required this.title}) : super(key: key); final String title; @override _MyHomePageState createState() => _MyHomePageState(); } class _MyHomePageState extends State { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(widget.title)), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text('You have pushed the button this many times:'), Text('$_counter', style: Theme.of(context).textTheme.headline4), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } } 网络请求示例 import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; class ApiDemo extends StatefulWidget { @override _ApiDemoState createState() => _ApiDemoState(); } class _ApiDemoState extends State { List _posts = []; Future fetchPosts() async { final response = await http.get( Uri.parse('https://jsonplaceholder.typicode.com/posts'), ); if (response.statusCode == 200) { setState(() { _posts = json.decode(response.body); }); } } @override void initState() { super.initState(); fetchPosts(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text('API Demo')), body: ListView.builder( itemCount: _posts.length, itemBuilder: (context, index) { return ListTile( title: Text(_posts[index]['title']), subtitle: Text(_posts[index]['body']), ); }, ), ); } } 进阶主题 状态管理方案 Flutter 提供了多种状态管理解决方案，适用于不同复杂度的应用： setState：适合局部状态管理 InheritedWidget：实现向下传递数据的机制 Provider：推荐的状态管理方案，基于 InheritedWidget 的封装 Riverpod：Provider 的改进版，解决了 Provider 的一些限制 Bloc/RxDart：响应式编程模式的状态管理 性能优化技巧 const 构造函数：尽可能使用 const 创建 widget const Text('Hello', style: TextStyle(fontSize: 16)); ListView.builder：用于长列表的懒加载 避免重建：使用 const 或 Provider 选择性重建 isolate：将计算密集型任务放到 isolate 中执行 平台特定功能集成 通过平台通道(Platform Channel)实现与原生平台的交互： // Dart 端 const platform = MethodChannel('samples.flutter.dev/battery'); Future getBatteryLevel() async { try { final result = await platform.invokeMethod('getBatteryLevel'); print('Battery level: $result%'); } on PlatformException catch (e) { print(\"Failed: '${e.message}'.\"); } } 对应的 Android(Kotlin)和 iOS(Swift)端需要实现相应的方法。 学习资源 官方文档：最权威的学习资源 Flutter 实战：中文社区优秀教程 Flutter Widget of the Day：官方 widget 介绍视频 Dart Pad：在线编写和运行 Dart 代码 常见问题解答 Q：Flutter 适合开发什么类型的应用？ A：Flutter 适合开发需要快速迭代、跨平台一致性的应用，特别是需要丰富自定义 UI 的场景。但对于需要深度集成平台特定功能的应用，可能需要更多原生开发工作。 Q：Dart 的学习曲线如何？ A：对于有 Java/JavaScript/C# 经验的开发者，Dart 很容易上手。其语法简洁，核心概念与多数现代语言相似。Flutter 框架的学习可能需要更多时间。 Q：Flutter 的性能如何？ A：Flutter 在大多数 UI 场景下性能接近原生，特别是在动画和滚动流畅度方面表现优异。但对于计算密集型任务，仍需考虑使用 isolate 或平台原生代码。 Q：Flutter 的生态系统成熟度如何？ A：截至 2023 年，Flutter 生态系统已相当成熟，pub.dev 上有超过 25,000 个包，覆盖大多数常见需求。但某些特定领域的第三方库可能不如 React Native 丰富。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 16:31:44 "},"跨端方案/uni-app.html":{"url":"跨端方案/uni-app.html","title":"Uni App","keywords":"","body":"uniapp 调试 官方调试教程 HBuilder 内置浏览器 优点：在线同步运行前端项目，边改边看，接口可跨域成功，可查看请求信息 弊端：运行不了 html5+ 相关的 真机调试 连接方式：usb 连接好后，通过【运行】-【运行到手机或模拟器】-【运行到 Android app 基座】 优点：可还原手机 app 运行环境；可以热更新 弊端：更新一点点都要重启 app，如果配置了账号密码、环境都要重新设置；需要抓包看网络请求；android 可用，ios 不可（截止至 22.10.25） 模拟器 优点：可还原手机 app 运行环境；可以热更新 弊端：windows 只能运行安卓模拟器；需要抓包看网络请求；运行有点慢 连接教程大部分可以参考: https://www.jianshu.com/p/f01efc0e4609 检查模拟器连接情况：新版本 HbuilderX 行不通了，可通过【运行】-【运行到手机或模拟器】-【运行到 Android app 基座】查看是否有设备名类似为【127.0.0.1:7555】 运行成功后一直闪退问题：回退 Hb 版本 3.4.x 之后 打开调试控制台：【视图】-【显示 webview 调试控制台】 # 连接 adb connect 127.0.0.1:7555 adb devices # HbuilderX 默认安卓端口26944 模拟器端口号 模拟器通过 bin 文件可以通过终端链接手机，操作内部环境，读写删手机文件 chrome webview 调试 真机或模拟器调试可以用 chrome 调试页面样式，当程序运行到基座后，打开 HubuilderX 的视图 -> 显示 Webview 调试控制台。 chrome 调试 app：https://blog.51cto.com/u_10624715/5270841 uni-app 只有 v3 模式下的 vue 页面支持 webview 调试：https://ask.dcloud.net.cn/article/36599 离线打包 uniapp 分两种更新机制： 完整包更新，包括 wgt 包 + uni 原生引擎 + 原生插件（这种方式比较繁琐，即每次更新之后就要打云包，更新整包，用户体验也不好） 资源包更新，包括 wgt（因第一种方法想到利用资源更新，用户体验大大提升，用户更新之后无需跳转到应用市场或者浏览器去重新更包，即无感更新）。wgt 是资源升级包，完整的前端资源，将前端的全部内容编译打包成 wgt。只有前端资源 wgt 可以热更新。 uniapp 离线打包（wgt）： 配置 manifeat.json 基础配置中的 appID、应用版本名称、应用版本号 点击窗口的【发行】-【原生 app-制作应用 wgt 包】 uni-app 跨平台应用开发之实现资源在线升级 混合开发 uniapp 编译提供的 wgt 包，宿主在原生 app 中 uniapp 向 app 发送指令，通过回调获取信息：uni.sendNativeEvent uniapp 监听 app 的指令：uni.onNativeEventReceive((event, data) => {}) others app 启用小程序时，在 onLaunch(opts) 的 opts 的可以获取到一些信息 获取 app 版本号：opts.referrerInfo.extraData.version 是否 debug 模式：opts.referrerInfo.extraData.isDebug HTML5+ 扩展规范 https://www.html5plus.org/doc/h5p.html HTML5+是中国 HTML5 产业联盟的扩展规范，基于 HTML5 扩展了大量调用设备的能力，使得 web 语言可以想原生语言一样强大。 html5+ 是 hbulider 利用自己的 IDE 结合不同平台的接口再加上 html5 的东西开发出来的一套框架，它有自己的使用规范，它允许和提供了一些接口和函数来让 web 开发者实现原生 app 所能实现的功能，Dcloud（开发 hublider 的公司）还在 hublider 提供了云打包功能，几乎是打包发布，帮那些不熟悉原生开发的开发人员节省了很多时间，国内类似的还有 Apicloud(提供了很多原生模块，而且编译发布什么的要比 hbulider 好一些，SDK 更新的比较勤，维护还是做的很不错的，最近在和 Dcloud 打官司)。hublider 的 native.js 就是一个接口库，调里面的接口就可以利用 hbulider 为你实现的和原生 api 结合的一些功能。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"跨端方案/uniapp.html":{"url":"跨端方案/uniapp.html","title":"Uniapp","keywords":"","body":"uniapp 常用 uniapp 生命周期执行顺序 // 进入应用 App Launch App Show page onLoad page onShow component beforeCreate component created component mounted page onReady // 应用后台 App Hide page onHide // 应用关闭 page onUnload component destory // 后台重新进入 App Show page onLoad page onShow 带来的问题： 每次切换页面的时候，组件的生命周期 created mounted，只能触发一次，解决方法：ref，在父组件的 onShow 调用子组件的方法 生命周期： 如果页面没有销毁但隐藏会触发 onHide，销毁也隐藏了触发 beforeDestroyed，onHide 和 beforeDestroyed 二者只会触发一次 onLoad 和 onShow navigateTo 调转，下一页会触发 onload 和 onshow，返回会触发 beforeDestroy 小程序缩小到后台，切换 app 再返回小程序会触发 onhide onshow 总结：除想要每次显示小程序都处理某些逻辑要使用 onShow，否则最好用 onload uniapp 跨组件触发事件 uni.$emit('xxx') .... 小程序分包 小程序主包最多只能 2M 的限制，当一个主包文件过多时，肯定面临着性能低，卡顿的情况。所以采用了分包的加载机制，将各个模块解耦。总包 20M 降低主包大小 外部根目录的 components 优化，只放使用率高的组件 尽量多分包，分包数量可支持 10 个左右，总包大小 20M 图片除底部栏外尽量使用网络图片 升级微信开发者工具，可提高打包效率压缩代码 打包原则 app（主包）也可以有自己的 pages（即最外层的 pages 字段） tabBar 页面必须在 app（主包）内 subpackages 配置路径外的目录将被打包到 app（主包） 中 声明 subpackages 后，将按 subpackages 配置路径进行打包 subpackage 的根目录不能是另外一个 subpackages 内的子目录 app.json 目录结构 微信原生是在同级分包，但 mpvue 同级会报错的，只能在 pages 中进行分包，在 subpackages 声明项目分包结构 app.json { \"pages\": [\"pages/home/main\", \"pages/tabbarpage.main\"], \"subPackages\": [ { \"root\": \"pages/subPage\", //分包根目录 \"name\": \"\", // 分包别名，分包预下载时可以使用 \"pages\": [ // 分包页面路径，相对于分包根目录 \"page1/main\", \"page2/main\" ], \"independent\": \"\" // 分包是否是独立分包 } ] } uniapp 小程序微信和支付宝端差异 class 和 style 语法 :class=\"xx: Boolean\" 注意事项： Boolean 不能是要通过复杂计算出的布尔，也不能是要经过默认转化的非布尔值 class 为多个值时可能会异常，判断不正确 支付宝兼容问题 组件传值为数组对象时，子组件修改值后支付宝界面未同步更新 子组件通过直接修改数组对象内容，数据都可以修改，微信可以渲染界面，但支付宝不行 可以将值通过 computed 复制一份，在该备份改完以后，forceupdate span 标签注册 click 事件失败，需要转为 div 样式空白屏 当使用 position: absolute;top: 0;bottom: 0; 撑开元素 A 时，需要注意 A 的父元素是否为根元素 body，如果不是需要给一个高度，否则会出现子是撑不开父的。 微信端容错性高，可以展示效果，支付宝不行。 样式边距错乱 支付宝端有时会对 box-sizing: border-box;不生效。如 /* 此时swiper-box的宽是铺满屏幕的，没有边距 */ .main-content-banner { width: 100%; height: 98px; padding-bottom: 16px; position: relative; .swiper-box { width: 100%; height: 98px; box-sizing: border-box; padding: 0 12px; text-align: center; } } 支付宝图片标签如果定义了 padding-bottom，会拉长图片的高，尽量用 margin 图片的背景如果用了 background-size: contain; 会使支付宝端高度不可控，与微信端不一致 vue 数据联动没反应 原则上子组件不能对 props 传值进行修改，包括对象。但微信端可直接引用该 props 对象，再 emit update 修改。支付宝端不行。 所以可采用 computed 复制 props 再引用，修改可用 emit update。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"通用工具/curl.html":{"url":"通用工具/curl.html","title":"Curl","keywords":"","body":"curl CURL (Client Url) 是一个利用 URL 语法在命令行下工作的文件传输工具。 应用 将浏览器的请求转换为 CURL 命令 浏览器端，找一个请求，右击复制格式，会有一个以 curl 格式复制，然后可以直接粘贴到浏览器控制台或终端发送请求，什么请求都可以发，不需要权限，因为复制的时候已经把关键信息带上来 有时候浏览器的请求你觉得不对了，可以直接把这个curl 发给后端 使用命令行往数据库读取数据 # 不带任何参数就是一个 get 请求 $ curl www.baidu.com # -d:post方式 $ curl -d 'name=hong&age=22' http://localhost:3000/users/addPerson 实现某些功能 yarn 版本升级： $ curl -o- -L https://yarnpkg.com/install.sh | bash Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"通用工具/gitbook.html":{"url":"通用工具/gitbook.html","title":"Gitbook","keywords":"","body":"Gitbook Setup # install $ npm install -g gitbook-cli # begin with nvm v10.24.1 $ gitbook install # generate summary by gitbook-summary $ book sm # or $ gitbook init # ouput $ gitbook build $ gitbook build ./ ./docs # development $ gitbook serve --port 6666 ✨ Gitbook Features GitBook GitBook Plugins generate a SUMMARY.MD via Gitbook Summary Automated deployment via Github Actions choose /docs via Github Pages Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"通用工具/网络抓包Charles.html":{"url":"通用工具/网络抓包Charles.html","title":"网络抓包Charles","keywords":"","body":"网络抓包 Charles Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 charles 下载地址 charles 教程 IOS 设备教程 Charles 抓包安卓模拟器（MuMu） 快速上手 [Charles] 设置系统代理的权限来完成封包截取 选择菜单中的“Proxy” –>“Mac OS X Proxy”或“Windows Proxy” [Charles] 打开代理功能 选择菜单中的“Proxy”–>“Proxy Settings”后编辑 Charles 端口号为 8888，勾上 “Enable transparent HTTP proxying” [iphone] 获取 Charles 的代理功能 在 iphone 当前连接的 wifi 里编辑内容“HTTP 代理“为手动代理，填上 Charles 运行所在的电脑的 IP，以及端口号 8888。（Charles 运行所在的电脑的 IP：Charles 的顶部菜单的 “Help”–>“Local IP Address”） 苹果手机还需要在的设置-通用-证书-允许 charles*** 证书 设置代理后，需要在电脑上配置并打开 Charles 才能上网。 [Charles] 安装证书 选择菜单中的“Help” –> “SSL Proxying” –> “Install Charles Root Certificate” 需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，有以下几种方法： Charles 在该请求上右击，选择 SSL proxy 直接设置所有网站：“Proxy” –> “SSL Proxying Settings”勾选 enable ssl Proxying，添加 include 的端口号*:443 [iphone] 安装证书 点击 Charles 的顶部菜单，选择 “Help” –> “SSL Proxying” –> “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。 如果设置完 HTTPS 代理 和证书之后，则所有的请求数据都将以明文显示，网络包不会显示错误 X 真机调试 真机测试：fiddler Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/":{"url":"项目工程化/","title":"项目工程化","keywords":"","body":"项目的工程化和自动化是一件很有意思的事情，通过自动化的工具，可以有效提升项目可维护性和质量，节省人力资源，并且避免很多不确定因素。 前端自动化/持续集成/持续部署 CI/CD： 前后端分离后，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节，提高了前端的开发效率和业务交付能力 工具：github、jenkins 前端开发如何让持续集成/持续部署(CI/CD)跑起来 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/github-action.html":{"url":"项目工程化/github-action.html","title":"Github Action","keywords":"","body":"使用 Github Actions 自动部署 VitePress 到 Github Pages 1. 准备工作 1.1 获取 GitHub Personal Access Token (PAT) 访问 GitHub Token 设置页面 点击 \"Generate new token\" → \"Generate new token (classic)\" 设置权限范围： 必须勾选 repo 权限（包含所有仓库权限） 如需访问私有仓库，还需勾选 workflow 权限 生成后务必立即复制保存（页面关闭后将无法再次查看） 1.2 添加 Token 到仓库 Secrets 进入你的 GitHub 仓库 → Settings → Secrets and variables → Actions 点击 \"New repository secret\" 名称填写 ACCESS_TOKEN，值粘贴刚才复制的 token 2. 项目配置 2.1 VitePress 基础配置 确保 docs/.vitepress/config.js 中已设置正确的 base 路径： export default { base: '/your-repo-name/', // 如果是用户/组织页面则用 '/' // 其他配置... } 2.2 使用 pnpm 的注意事项 在项目根目录添加 pnpm-lock.yaml 文件（如果不存在） 创建 .npmrc 文件并添加：shamefully-hoist=true 推荐在 package.json 中添加部署脚本：\"scripts\": { \"docs:build\": \"vitepress build docs\", \"docs:preview\": \"vitepress preview docs\" } 3. GitHub Actions 配置 3.1 创建工作流文件 在 .github/workflows 目录下创建 deploy.yml 文件： name: Deploy VitePress to GitHub Pages on: push: branches: [main] # 或 master，根据你的主分支名称 jobs: deploy: runs-on: ubuntu-latest permissions: contents: write # 允许工作流写入仓库 steps: - uses: actions/checkout@v4 with: fetch-depth: 0 # 获取完整历史记录 - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: 20 # 推荐使用 LTS 版本 cache: 'pnpm' # 启用 pnpm 缓存 - name: Install pnpm uses: pnpm/action-setup@v2 with: version: 8 # 指定 pnpm 版本 - name: Install dependencies run: pnpm install --frozen-lockfile - name: Build VitePress run: pnpm docs:build - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.ACCESS_TOKEN }} publish_dir: docs/.vitepress/dist keep_files: false # 清除旧文件 force_orphan: true # 强制使用单次提交 3.2 工作流配置说明 缓存优化：setup-node 的 cache: 'pnpm' 可以显著加速后续构建 权限控制：contents: write 是部署到 gh-pages 分支的必要权限 部署选项： keep_files: false 确保每次部署都是全新状态 force_orphan: true 创建干净的提交历史 4. 常见问题排查 4.1 部署失败常见原因 Token 权限不足：确保 token 有 repo 权限 base 路径错误：用户页面应为 /，项目页面应为 /repo-name/ 分支保护：检查仓库设置中是否限制了 gh-pages 分支的写入 4.2 缓存优化技巧 可以添加额外缓存步骤加速构建：- name: Cache VitePress build uses: actions/cache@v3 with: path: | docs/.vitepress/cache node_modules 5. 进阶配置 5.1 自定义域名 在 docs/.vitepress/config.js 中设置 base: '/' 在仓库 Settings → Pages 中设置 Custom domain 在项目根目录添加 CNAME 文件（内容为你的域名） 5.2 多环境部署 可以扩展工作流实现开发/生产环境分离： jobs: deploy-dev: if: github.ref == 'refs/heads/dev' # 开发环境配置... deploy-prod: if: github.ref == 'refs/heads/main' # 生产环境配置... 6. 参考资源 VitePress 官方部署指南 GitHub Actions 官方文档 pnpm 与 GitHub Actions 集成 修改包管理器为 pnpm：setup-node Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 17:08:15 "},"项目工程化/monorepo.html":{"url":"项目工程化/monorepo.html","title":"Monorepo","keywords":"","body":"monorepo 方案 pnpm workspaces yarn workspaces lerna + yarn workspaces pnpm workspaces 🌰： hazel-plus(ui) 两个官网重构合并（nuxt2.17） 两个官网重构合并（nuxt2.17） pnpm 配置，使用旧 npm 安装依赖的方式 .npmrc shamefully-hoist=true auto-install-peers=true strict-peer-dependencies=false 项目中的别名 alias 重新定义引用路径 import { resolve } from 'path' const config = { alias: { '@': resolve(__dirname, '../..'), }, } 配置 ts 类型解析路径 tsconfig.json { \"extends\": \"./tsconfig.base.json\", \"compilerOptions\": { \"baseUrl\": \"../../\", \"paths\": { \"@/*\": [\"./*\"] } } } pnpm workspaces 项目部署 经常会有异常报错，如本地编译构建正常，发线上部署则报错，坑点可能是依赖问题，lock 文件没有锁好，某个依赖被升级了然后导致问题 workspaces Quick Start：用 pnpm 管理 Monorepo 项目 link 机制 在 monorepo 中，我们往往需要解决 package 间的引用，比如 @panda/tools 会被 @panda/server 和 @panda/web 依赖。 \"dependencies\": { \"@panda/tools\": \"workspace:^1.0.0\", // 通过 workspace 为本地引用 }, 通过软链接引用了 tools package，可以在 web 项目下的 node_modules 看到对应的代码已经提升了。 发布 workspace 包 当这样的工具包被发布到平台后，如何识别其中的 workspace 呢？ 需要 workspace 包打包到归档，可以通过pnpm pack 或 pnpm publish 之类的发布命令，将动态替换这些 workspace 依赖，把基于的 workspace 的依赖变成外部依赖，解决了开发环境和生产环境对依赖的问题。 注意：必须是用 pnpm 的命令才能起效 yarn workspaces package.json 配置 { \"private\": true, \"license\": \"MIT\", \"version\": \"1.0.0\", \"workspaces\": [\"apps/*\"], \"scripts\": { \"xxx:dev\": \"yarn workspace xxx run dev\" } } lerna + yarn workspaces https://blog.csdn.net/frontend_frank/article/details/115344129 # 全局安装，lerna 测试版本为 5.6.2 $ npm install -g lerna@5.6.2 # 空项目初始化 lerna 项目 $ lerna init # 执行 apps 项目下 xxx-a 项目的 script 指令 dev，如果不加 --stream，运行结果只会提示最后一句 run dev 就什么信息都不会报 $ lerna run dev --scope xxx-a --stream # 查看 lerna 指令 $ lerna run --help 如果在旧项目重构成 lerna monorepo 项目则手动加 lerna.json 文件 lerna.json { \"$schema\": \"node_modules/lerna/schemas/lerna-schema.json\", \"version\": \"independent\", // lerna默认使用的是集中版本，所有的package共用一个version,如果需要packages下不同的模块 使用不同的版本号，需要配置Independent模式 \"packages\": [\"apps/*\"], \"useWorkspaces\": true, \"npmClient\": \"yarn\", \"useNx\": false } turborepo https://turbo.build/ Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/qiankun.html":{"url":"项目工程化/qiankun.html","title":"Qiankun","keywords":"","body":"qiankun main：主应用，作为一个外壳，集合多个子应用 sub：子应用，每个子应用都是独立的项目，独立配置且需要独立部署 🌰：https://github.com/umijs/qiankun/examples # 当时测试用的 node 版本 nvm use 16.15.0 # 根目录 npm i # 每个 examples 的应用 npm i npm run examples:start qiankun 样式隔离 默认的 qiankun 案例项目是没开启 css 隔离，所有的 css 都在全局，这样各应用的样式会相互影响，比如主应用和子应用。 qiankun 提供了两种样式隔离方案：shadow dom 和自己实现的 scoped。 shadow dom shadow dom 是 web components 技术的一部分，其实就一个 attachShadow 的 api。web components 添加内容的时候，不直接 appendChild，而是先 attach 个 shadow，然后再在下面 appendChild。 开启 shadow dom 后，shadow dom 内的样式和外界互不影响。但由于弹窗默认是挂在 body 上的，也就不在 shadow dom 里了，那 shadow dom 里给它加的样式自然就不生效了，所以弹窗的样式就丢失了。 multiple.js qiankun 开启 shadow dom loadMicroApp( { name: 'vue', entry: '//localhost:7101', container: '#vue' }, { sandbox: { strictStyleIsolation: true } }, ); qiankun 实现的 scoped scoped 的方案是给选择器加了一个 data-qiankun='应用名' 的选择器，这样父应用能设置子应用样式，这样能隔离样式，但是同样有挂在 body 的弹窗样式设置不上的问题，因为 qiankun 的 scoped 不支持全局样式 multiple.js qiankun 开启 scoped loadMicroApp( { name: 'vue', entry: '//localhost:7101', container: '#vue' }, { sandbox: { experimentalStyleIsolation: true } }, ); 解决方案 react 和 vue 项目本身都会用 scoped css 或者 css modules 的组件级别样式隔离方案，这俩方案都支持传递样式给子元素、设置全局样式等，只是实现和使用方式不同。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 17:31:39 "},"项目工程化/rollup-pack-node.html":{"url":"项目工程化/rollup-pack-node.html","title":"Rollup Pack Node","keywords":"","body":"rollup 打包 node commonjs 项目 使用 rollup 打包启动项目 rollup.config.mjs // pnpm add -D @rollup/plugin-commonjs @rollup/plugin-node-resolve import resolve from '@rollup/plugin-node-resolve' import commonjs from '@rollup/plugin-commonjs' export default [ { plugins: [resolve(), commonjs()], input: './packages/Json2Interface/index.js', output: { file: './dist/index.js', format: 'cjs', }, external: ['chalk', 'commander', 'inquirer', 'ora', 'request', 'fs', 'quicktype-core'], }, ] package.json { \"scripts\": { \"rollup:Json2Interface\": \"rollup -c rollup.config.mjs\" } } // 使用 const { output } = require('../dist/index.js') Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/vite-pack-node.html":{"url":"项目工程化/vite-pack-node.html","title":"Vite Pack Node","keywords":"","body":"vite 打包 node commonjs 项目 vite.config.js // pnpm add -D vite-plugin-commonjs import commonjs from 'vite-plugin-commonjs' import { resolve } from 'path' export default { plugins: [ commonjs({ include: /Json2Interface/, extensions: ['.js'], // 需要转换的文件扩展名 ignoreGlobal: false, // 是否忽略全局变量（例如 Buffer） sourceMap: false, // 是否生成源映射 namedExports: {}, // 命名导出（名称和值） ignore: [], // 忽略文件的正则表达式 transformMixedEsModules: true, // 是否转换混合的 ES 模块 }), ], build: { target: 'modules', minify: true, lib: { entry: './index.js', name: 'Json2Interface', }, rollupOptions: { external: ['chalk', 'commander', 'inquirer', 'quicktype-core', 'ora', 'request', 'fs'], input: ['./index.js'], output: [ { format: 'cjs', //不用打包成.mjs entryFileNames: '[name].js', //让打包目录和我们目录对应 preserveModules: true, //配置打包根目录 dir: resolve(__dirname, '../../dist/Json2Interface'), }, ], }, }, } package.json { \"scripts\": { \"build:Json2Interface\": \"pnpm --filter=Json2Interface build\" } } // 使用 const { output } = require('../dist/Json2Interface/index.js') Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/代码提交规范.html":{"url":"项目工程化/代码提交规范.html","title":"代码提交规范","keywords":"","body":"git commit 代码提交规范 Conventional Commits 约定式提交 统一团队 Git Commit 标准，便于后续代码 review、版本发布、自动化生成 change log 或 release note 可以提供更多更有效的历史信息，方便快速预览以及配合 cherry-pick 快速合并代码 团队其他成员进行类 git blame 时可以快速明白代码用意 校验辅助工具 husky: supports all Git hooks, can lint your commit messages, run tests, lint code, etc... commitlint: Lint commit messages # 安装husky和commitlint $ pnpm add -D husky @commitlint/config-conventional @commitlint/cli # warning: 以下命令适用于husky8 # 安装husky提供的git hook：package.json > prepare script 的prepare脚本会在执行npm install之后自动执行 $ npm set-script prepare \"husky install\" $ npm run prepare # git hook(pre-commit)：提交git commit命令前触发，脚本内容自定义，一般添加eslint $ npx husky add .husky/pre-commit \"xxx\" # git hook(commit-msg)：规范 commit message 信息，需要配置commitlint $ npx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"' $ echo \"module.exports = {extends: ['@commitlint/config-conventional']}\" > commitlint.config.js 配置 commitlint 时 Windows 可能出现的问题： 文件编码格式应该为 UTF-8 package.json 中的 type 属性配置：commitlint.config.js -> \"commonjs\"，commitlint.config.cjs -> \"module\" @commitlint/config-conventional 类型默认包括：[build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] commit 说明 例子： feat(cli): create initial commit fix: feat(0429 留言下单): add 'graphiteWidth' option 规范： type(scope): subject type：用于说明 commit 的类别，规定为如下几种： feat：新增功能（feature） fix：修复 bug style：仅仅修改了空格、缩进等，不改变代码逻辑 refactor：代码重构，未新增任何功能和修复任何 bug chore：非 src 和 test 的修改构建过程或辅助工具的变动（杂项） docs：修改文档（documentation） perf：改善性能和体现的修改 test：测试用例的修改 ci：自动化流程配置修改 revert：回滚到上一个版本 build：改变构建流程，新增依赖库、工具等（例如 webpack 修改）(可选） scope：【可选】用于说明 commit 的影响范围，比如: route, component, utils, build... subject：commit 的简要说明，不超过 50 个字符，以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes 第一个字母小写结尾不加句号（.） 如果修改范围以上都应用不了，可能就是 commit 合并太多 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/代码校验.html":{"url":"项目工程化/代码校验.html","title":"代码校验","keywords":"","body":"代码校验 eslint 使用 eslint 来预先制定编码规范，借助编辑器的错误检测和格式化来格式化代码，有效控制代码质量，也省去了很多手工操作。 在项目根目录添加 .eslintrc.js 文件，用于校验代码，编写 eslint 相关规则。 配置 全局配置 使用全局安装 ESLint 后，使用的任何 ESLint 插件或可分享的配置也需要全局安装。 # 全局安装 $ pnpm add -g eslint # 在有 package.json 文件的项目中初始化 $ eslint --init 在 VSCode 配置文件 setting.json setting.json { // 如果使用 yarn 全局安装 eslint，要在 vscode 编辑器的 setting.json 改变此项 \"eslint.packageManager\": \"yarn\", \"eslint.options\": { // 指定 .eslintrc.js 配置文件路径即可启用自定义规则检测，ESLint 会查找并自动读取 \"configFile\": \"E:/git/github/styleguide/eslint/.eslintrc.js\", // ESLint 默认只支持 js 文件的脚本检测，如果我们需要支持类 html 文件（如 vue）的内联脚本检测，还需要安装 eslint-plugin-html 插件 \"plugins\": [\"html\"] }, \"eslint.validate\": [\"javascript\", \"javascriptreact\", \"html\", \"vue\"] } 项目配置 如果仅仅想让 ESLint 成为项目构建系统的一部分，也可以在项目根目录进行本地安装 # 安装 eslint & prettier $ pnpm install -D eslint eslint-config-prettier eslint-plugin-prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-plugin-vue # 初始化 $ pnpm eslint --init 配置好规则文件后，安装编辑器检查插件，比如 vscode 中添加 eslint 和 vetur 插件，安装好了之后，会自动根据你上面配置的规则进行代码检查，不合格的会高亮显示。 具体配置 使用 .eslintrc.* 文件（支持 JSON 和 YAML 两种语法） .eslintrc 放在项目根目录，则会应用到整个项目；如果子目录中也包含 .eslintrc 文件，则子目录会忽略根目录的配置文件，应用该目录中的配置文件。这样可以方便地对不同环境的代码应用不同的规则。 module.exports = { // 指定要启用的环境，以保证在进行代码检测时不会把这些环境预定义的全局变量识别成未定义的变量而报错 env: { browser: true, es6: true, node: true, }, // 启用推荐规则 extends: ['eslint:recommended', 'plugin:vue/essential'], // 脚本在执行期间访问的额外的全局变量 globals: { Atomics: 'readonly', SharedArrayBuffer: 'readonly', }, // 指定解析器 parse: '', // 指定想要支持的 JavaScript 语言选项, 指定解析器选项 parserOptions: { ecmaVersion: 2018, sourceType: 'module', }, plugins: ['vue'], // 启用的规则及其各自的错误级别 rules: {}, // 别人可以直接使用你配置好的ESLint root: true, } 在 package.json 中添加 eslintConfig 配置块 { \"name\": \"mypackage\", \"version\": \"0.0.1\", \"eslintConfig\": { \"env\": { \"browser\": true, \"node\": true } } } 直接在代码文件中定义 代码文件内配置的规则会覆盖配置文件里的规则。 局部禁用 eslint: 单个 js 文件禁用 ESLint 语法校验：在代码顶部添加一行注释 /* eslint-disable */ 禁用某个代码块的校验：在代码块顶部和底部加 /* eslint-disable */ 避开指定的校验规则 /* eslint-disable no-new */ 禁用当前行：在当前行 // eslint-disable-line 禁用下一行：在上一行 // eslint-disable-next-line 忽略校验 在 package.json 配置 \"eslintIgnore\" 或添加文件 .eslintignore 创建自己风格的 eslint 插件 package.json { \"eslintConfig\": { \"root\": true, \"extends\": [\"xxx\"] } } Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/代码格式化.html":{"url":"项目工程化/代码格式化.html","title":"代码格式化","keywords":"","body":"代码格式化 prettier prettier 是一款强势武断的代码格式化工具，它几乎移除了编辑器本身所有的对代码的操作格式，然后重新显示。就是为了让所有用这套规则的人有完全相同的代码。在团队协作开发的时候更是体现出它的优势。与 eslint，tslint 等各种格式化工具不同的是，prettier 只关心代码格式化，而不关心语法问题。 配置 vscode 安装 prettier 插件 全局配置：setting.json 项目配置：prettier.config.js、.prettierrc setting.json // \"prettier.configPath\": \"./prettier.config.js\", \"prettier.printWidth\": 110, \"prettier.tabWidth\": 2, \"prettier.singleQuote\": true, \"prettier.semi\": false, \"prettier.useTabs\": false, \"prettier.trailingComma\": \"es5\", \"prettier.bracketSpacing\": true, \"prettier.arrowParens\": \"avoid\", \"prettier.proseWrap\": \"preserve\", \"prettier.endOfLine\": \"auto\", \"prettier.htmlWhitespaceSensitivity\": \"ignore\", \"prettier.bracketSameLine\": false, \"prettier.vueIndentScriptAndStyle\": true, \"prettier.useEditorConfig\": false, prettier 限制 standard 规则要求函数名和括号之间有一个空格，这就是 space-before-function-paren 规则（ESLint 本身也会默认开启这个规则）。 但是 prettier 完全没有这个规则。 解决： eslint 和 prettier 会有冲突，安装prettier-eslint包 prettier 的一些规则和 eslint 的一些规则可能存在冲突，所以需要将 eslint 的一些可能与 prettier 发生冲突的代码格式化规则关闭。每次 git commit 的时候，要先执行 prettier 以及 eslint 对代码进行格式化和质量检查，确保代码没有问题之后再提交。 Vue 项目使用 eslint + prettier 规范代码风格 prettier-eslint 是怎么让结果变得正确了呢？昨天我去它的 github 看了看，原来它是先把代码用 prettier 格式化，然后再用 ESLint fix。这和 vscode 保存文件时的流程是相反的。这样等于是调转了顺序，最后我们只要 ESLint fix 的结果就行了。 其他点 .prettierrc 的优先级会高于在 vscode 全局配置 settings.json 中格式化配置的优先级 vetur + prettier Vetur 插件内部默认使用 prettier 进行格式化的，但是由于 Vetur 的默认格式化配置与我们期望的有所出入，所以我们需要单独对 Vetur 的 prettier 进行配置 配置 配置格式化方式为 ts setting.json // prettier在格式化的时候 函数名后不会留有空格。需要使用vetur调用vscode自带的ts格式化插件解决这个问题。 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true \"vetur.format.defaultFormatterOptions\": { \"prettier\": { \"semi\": false, // 格式化不加分号 \"singleQuote\": true, // 格式化以单引号为主 \"printWidth\": 120, // 超过最大值换行 \"tabWidth\": 2, // 缩进字节数 \"useTabs\": false, // 缩进不使用tab，使用空格 \"proseWrap\": \"preserve\", // 代码超出是否要换行 preserve保留 \"arrowParens\": \"avoid\", // (x) => {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"{ foo: bar }\" \"disableLanguages\": [\"vue\"], // 不格式化vue文件，vue文件的格式化单独设置 \"endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"eslintIntegration\": true, //不让prettier使用eslint的代码格式进行校验 \"htmlWhitespaceSensitivity\": \"ignore\", \"jsxBracketSameLine\": false, // 在jsx中把'>' 是否单独放一行 \"jsxSingleQuote\": false, // 在jsx中使用单引号代替双引号 \"parser\": \"babylon\", // 格式化的解析器，默认是babylon \"requireConfig\": false, // Require a 'prettierconfig' to format prettier \"stylelintIntegration\": false, //不让prettier使用stylelint的代码格式进行校验 \"trailingComma\": \"es5\", // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号） \"tslintIntegration\": true, // 不让prettier使用tslint的代码格式进行校验 \"ignorePath\": \".prettierignore\" // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 }, \"js-beautify-html\": { // - auto: 仅在超出行长度时才对属性进行换行。 // - force: 对除第一个属性外的其他每个属性进行换行。 // - force-aligned: 对除第一个属性外的其他每个属性进行换行，并保持对齐。 // - force-expand-multiline: 对每个属性进行换行。 // - aligned-multiple: 当超出折行长度时，将属性进行垂直对齐。 \"wrap_attributes\": \"auto\", \"wrap_line_length\": 100 } }, 需要增加其他配置，才能让 vetur 下的 format 生效 setting.json // 默认的格式化程序 【重要】：配置了才会生效 \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, \"vetur.format.defaultFormatter.js\": \"prettier\", // 配置成 prettier，vetur下的prettier才生效 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/无框架项目gulp篇.html":{"url":"项目工程化/无框架项目gulp篇.html","title":"无框架项目gulp篇","keywords":"","body":"官网工程化 - gulp 篇 gulp gulp 是一种基于流的自动化构建工具，基于 nodeJs 中的 stream（流）来读取和写入数据，相对于 grunt 直接对文件进行 IO 读写来说速度更快。 借助于 gulp，我们可以自动化地完成 js/sass/less/css 等文件的的测试、检查、合并、压缩、格式化，并监听文件在改动后重复指定的这些步骤。 要点： 文件压缩（cssnano uglify-js imgmin） babel 转换 图片转 base64 px2rem css 雪碧图 自动添加 css 前缀 autoprefixer 组件复用 代码复用：为了代码的可复用性和可维护性（减少需要变动时的修改范围） 插件gulp-file-include：a plugin of gulp for file include 用法 教程：HTML 代码复用实践 目录： |-node_modules |-src |-include |-index.html |-dist gulpfile.js gulpfile.js var gulp = require('gulp') var fileinclude = require('gulp-file-include') gulp.task('fileinclude', function () { gulp .src('src/index.html') .pipe(fileinclude({ prefix: '@@', basepath: '@file' })) .pipe(gulp.dest('dist')) }) 这里的@file 就是指src/index.html，引入到该页面。basepath 就是指公用组件存在的位置。 tips 最后构建出来的 include 公用文件会合并到 dist/index.html 里。不会生成单独的文件。 src/index.html 引入公共文件时仍需要添加相应的路径：@@include('include/header.html') 但公用文件里设置链接时需要考虑 build 出后的相应路径 因为共用的组件是相同的，所以如果组件里有链接，要使用这个组件的页面需要在同一路径下，才不会链接错误。 css 雪碧图 使用雪碧图：目的是减少网络传输，但设置背景图尺寸大小，感觉很麻烦，而且雪碧图的维护也不怎么便利，好像使用率越来越低了，都被 iconfont 取代了，也可以用构建工具 background-image background-position iconmoon iconmoon 是一个在线工具，可以上传自己的 SVG 格式的图标文件，也可以从其中选择已有的图标， 定制出自己的字体文件。 小图标等用 iconfont 代替：作为单个 DOM 节点使用，可以设置大小、颜色等，非常便利。 个人建议前端来维护这个字体包，每次有新增的图标，让设计师给我们对应的 svg 文件即可，前端自己去 icomoon.io/ 这个网站，导入原来的 selection.json 文件，增量生成新的 css，无比方便。之前，我一直以为 iconfont 只能是单色的呢，其实也可以是多色的，svg 里面多一些 path 而已，设计师会搞定的。生成字体后，前端正常引用即可（引用的时候，多色字体会多一些标签） 使用 base64 格式的图片：有些小图片，可能色彩比较复杂，这个时候再用 iconfont 就有点不合适了，此时可以将其转化为 base64 格式（不能缓存），直接嵌在 src 中，比如 webpack 的 url-loader 设置 limit 参数即可 Writing efficient CSS selectors 私有前缀 css 采用 autoprefixer 或者 prefixfree 等，让 CSS 真正的 Write once, run anywhere。 css 带前缀的是浏览器私有实现，不带前缀的是标准，加前缀是为了兼容 PC 端： 不需要在源代码中写私有有属性前缀了，只需要控制你自己需要兼容什么样的浏览器版本。正确的姿势是在项目构建阶段，用autoprefixer这个工具来为编译后的 css 自动补全所需的前缀。无论你是用 webpack、gulp、grunt 还是 fis，它都能完美配合。 这个工具中内置了非常详尽的数据，描述每个私有有属性在浏览器下的各版本下，是否需要前缀。配置该工具的时候，只要指明需要兼容的浏览器版本，它就会很智能的按需添加前缀了。如果私有语法与标准有差异，它也能自动处理。 只有一种情况下例外，还是要写前缀，那就是你写的这条 css 属性没有对应的 w3c 标准语法。 移动端： 目前大部分设备的浏览器都是基于 webkit 实现的，虽然其它厂商的也有，但不是主流。所以，移动端可以几乎不用加这些私有前缀，个别由于版本迭代，需要加-webkit-前缀兼容低版本的浏览器就行了。 浏览器版本 browserslist 可以写在 package.json 里 https://github.com/browserslist/browserslist#readme \"browserslist\": [ \"last 1 version\", \"> 1%\", \"maintained node versions\", \"not dead\" ] autoprefixer({ browsers: ['last 5 versions', 'Android >= 4.0'], cascade: true, // 是否美化属性值 默认：true 像这样： // -webkit-transform: rotate(45deg); // transform: rotate(45deg); remove: true, // 是否去掉不必要的前缀 默认：true }) gulp 配置 gulpfile.js const gulp = require('gulp') const postcss = require('gulp-postcss') const sourcemaps = require('gulp-sourcemaps') const autoprefixer = require('autoprefixer') // 添加css前缀 const del = require('del') // 清空目录 const concat = require('gulp-concat') // 文件合并 const connect = require('gulp-connect') // 起server服务 const cssnano = require('gulp-cssnano') // 压缩css const htmlmin = require('gulp-htmlmin') // 压缩html const imagemin = require('gulp-imagemin') // 压缩图片 const pngquant = require('imagemin-pngquant') // 压缩png图片 const spritesmith = require('gulp.spritesmith') // 合并sprite图片 const uglify = require('gulp-uglify') // 压缩js const cache = require('gulp-cache') // 缓存资源 const base64 = require('gulp-base64') // 转换图片 const fileinclude = require('gulp-file-include') // 组件复用 const gutil = require('gulp-util') //排错小工具 const preprocess = require('gulp-preprocess') /* CLEAN: 清空dist目录 * ------------------------------------------------------ */ gulp.task('clean', async () => { await del(['./dist']) }) /* HTML: 压缩，开发热更新，生产环境 * ------------------------------------------------------ */ const htmlMin = () => { return gulp .src(['./src/*.html', './src/include/*.html']) .pipe( fileinclude({ prefix: '@@', basepath: '@file', indent: true, }) ) .pipe( htmlmin({ collapseWhitespace: true, minifyJS: true, minifyCSS: true, removeComments: true, }) ) .pipe(gulp.dest('./dist/')) } gulp.task('html:dev', async () => { await htmlMin().pipe(connect.reload()) }) gulp.task('html:build', async () => { await htmlMin() }) /* CSS：前缀、转图片为base64、合并重命名、压缩 * ------------------------------------------------------ */ const cssMin = () => { return ( gulp .src('./src/assets/css/*.css') .pipe(sourcemaps.init()) .pipe(postcss([autoprefixer()])) // .pipe(sourcemaps.write(\".\")) .pipe( base64({ maxImageSize: 8 * 1024, // 只转8kb以下的图片为base64 }) ) .pipe(concat('main.min.css')) .pipe(cssnano()) .pipe(gulp.dest('./dist/assets/css')) ) } gulp.task('css:dev', async () => { await cssMin().pipe(connect.reload()) }) gulp.task('css:build', async () => { await cssMin() }) /* JS：合并压缩 * ------------------------------------------------------ */ const jsMin = () => { return gulp .src('./src/assets/js/*.js') .pipe(preprocess({ context: { NODE_ENV: 'production' } })) .pipe(concat('main.min.js')) .pipe( uglify().on('error', function (err) { gutil.log(gutil.colors.red('[Error]'), err.toString()) this.emit('end') }) ) .pipe(gulp.dest('./dist/assets/js')) } const jsMinDev = () => { return gulp .src('./src/assets/js/*.js') .pipe(preprocess({ context: { NODE_ENV: 'development' } })) .pipe(concat('main.min.js')) .pipe( uglify().on('error', function (err) { gutil.log(gutil.colors.red('[Error]'), err.toString()) this.emit('end') }) ) .pipe(gulp.dest('./dist/assets/js')) } gulp.task('js:dev', async () => { await jsMinDev().pipe(connect.reload()) }) gulp.task('js:build', async () => { await jsMin() }) /* IMAGE：压缩 * ------------------------------------------------------ */ const imageMin = () => { return gulp .src(['./src/assets/img/*.png', './src/assets/img/*.jpg']) .pipe(cache(imagemin({ progressive: true, use: [pngquant()] }))) .pipe(gulp.dest('./dist/assets/img')) } // 合并sprite图 const spriteData = () => { return gulp .src('./src/assets/img/sprite/*.png') .pipe( spritesmith({ imgName: 'img/sprite.png', cssName: 'css/sprite.css', cssFormat: 'css', padding: 10, }) ) .pipe(gulp.dest('./dist/assets')) } gulp.task('image:dev', async () => { await imageMin().pipe(connect.reload()) await spriteData().pipe(connect.reload()) }) gulp.task('image:build', async () => { await imageMin() await spriteData() }) /* DEV：开发环境执行对应的开发任务 * ------------------------------------------------------ */ // 监听源文件变化 gulp.task('watch', () => { gulp.watch('./src/assets/css/*.css', gulp.series('css:dev')) gulp.watch('./src/assets/js/*.js', gulp.series('js:dev')) gulp.watch(['./src/assets/img/*.png', './src/assets/img/*.jpg'], gulp.series('image:dev')) gulp.watch('./src/**/*.html', gulp.series('html:dev')) }) // 启动服务 // visit localhost:3000 gulp.task('server', () => { connect.server({ root: './dist', // 以根目录作为入口 port: 3000, livereload: true, }) }) const gulpdev = () => { return gulp.series(gulp.parallel('watch', 'server')) } gulp.task('dev', gulp.series(gulp.parallel('watch', 'server'))) /* BUILD：生产环境执行对应的构建任务 * ------------------------------------------------------ */ gulp.task('build', gulp.series('clean', gulp.parallel('html:build', 'js:build', 'image:build', 'css:build'))) /* TEST：测试环境执行对应的构建任务 * ------------------------------------------------------ */ gulp.task('test', gulp.series('clean', gulp.parallel('html:build', 'js:dev', 'image:build', 'css:build'))) Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "},"项目工程化/模块联邦Module-Federation.html":{"url":"项目工程化/模块联邦Module-Federation.html","title":"模块联邦Module-Federation","keywords":"","body":"模块联邦 Module Federation Module Federation 是 webpack5 提供的用于应用之间共享模块的机制，只要用 ModuleFederationPlugin 声明 exposes 的模块，另一个应用里用 ModuleFederationPlugin 声明 remotes 导入的模块，就可以直接用别的应用的模块了。这就是它为什么会叫模块联邦。 除了业务模块外，库模块也可以共享。只不过要注意这些模块都是异步加载的，所以要用 import()来异步引入。单独引入异步组件需要用 React.lazy(() => import('xx/yy')) 的形式，或者把整个应用用 import() 来异步加载。 此外，还要注意要固定 output.publicPath，不然引入模块的时候路径会有问题。 webpack.config.js aaa 的 webpack 配置 // visit aaa: localhost:3000 const { ModuleFederationPlugin } = require('webpack').container; module.exports = function () { return { output: { // webpack uses `publicPath` to determine where the app is being served from. // It requires a trailing slash, or the file assets will get an incorrect path. // We inferred the \"public path\" (such as / or /my-project) from homepage. // publicPath: paths.publicUrlOrPath, publicPath: 'http://localhost:3000/', }, plugins: [ new ModuleFederationPlugin({ name: 'aaa_app', filename: 'aaaEntry.js', // 创建一个 name 为 aaa_app 的共享包。这个共享包 exposes 暴露出了 Button 这个共享模块。它对应的文件名是 aaaEntry.js。 // 重跑服务后会看到页面请求了 aaaEntry.js 这个文件，里面声明了一个 aaa_app 的变量。这就是说 webpack 把这个组件的代码分离到了这个文件里。这样别的 webpack 应用就可以直接用这个组件了。 exposes: { './Button': './src/Button/index.jsx', }, remotes: { 'bbb-app': 'bbb_app@http://localhost:3001/bbbEntry.js', } // 除了导出业务模块外，库的模块也可以共用，比如 react、react-dom 这种库。 shared: { react: { singleton: true, }, 'react-dom': { singleton: true, } }, }), ], }; }; webpack.config.js bbb 的 webpack 配置 // visit bbb: localhost:3001 // 引入 aaa 的 Button 组件 const { ModuleFederationPlugin } = require('webpack').container; module.exports = function () { return { publicPath: 'http://localhost:3001/', plugins: [ new ModuleFederationPlugin({ name: 'bbb_app', filename: 'bbbEntry.js', // 导出 bbb 应用的 link 组件 exposes: { './Link': './src/Link/index.jsx' }, // 引入的时候使用 remotes 注册，这段配置就是注册了一个运行时的 Module，名字叫 aaa-app，它的值来自 http://localhost:3000/aaaEntry.js 这个文件里的 aaa_app 变量。 remotes: { 'aaa-app': 'aaa_app@http://localhost:3000/aaaEntry.js' }, shared: { react: { singleton: true, }, 'react-dom': { singleton: true, } }, }), ], }; }; app.jsx bbb 使用 aaa 的 Button // 因为是异步组件，所以用 React.lazy 包裹，具体取这个组件的逻辑就是用 webpack 提供的 import() 来异步加载模块。 const RemoteButton = React.lazy(() => import('aaa-app/Button')); 模块级微前端 Module Federation Module Federation 是天生的模块级微前端，它和 qiankun 一样，都是用到另一个应用的代码时，异步去某个地址下载它的代码，然后跑起来，只不过一个是应用级，一个是模块级。 因为微前端做的事情不就是一个应用里复用另一个应用的代码么？只不过一般是整个应用的共享，比如 qiankun 是在主应用里注册微应用的地址，并且在微应用里写一下加载、卸载等生命周期的函数。这样就可以在路由切换的时候，自动加载微应用并执行它的生命周期函数来激活它。微前端也就是多了一个异步加载应用的逻辑。 而 Module Federation 呢？是在一个应用里注册另一个应用的模块代码，当用到这些模块的时候，webpack 会异步加载对应的 chunk，拿到对应变量的值，也就是共享的模块。这个和应用级别的微前端不是一样的流程么？都是异步加载并执行代码。 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-07-06 17:23:27 "},"项目工程化/版本发布规范.html":{"url":"项目工程化/版本发布规范.html","title":"版本发布规范","keywords":"","body":"自动版本化和生成 CHANGELOG 工具 standard-version: include lifecycle steps（bump, changelog, commit, tag） 自动修改 package.json 的 version 生成 changlog 提交当前记录 打 git tag 安装 # 安装standard-version $ pnpm add -D standard-version # Add an npm run script to your package.json $ npm set-script release \"standard-version\" 使用 # –release-as, -r 指定版本号 # 示例 version = v1.0.0 # 万能 $ npm release -r x.x.x # v2.0.0 $ npm release -r major # v1.1.0 $ npm release -r minor # v1.0.1 $ npm release -r patch # v1.0.1-0 $ npm release -r prepatch 跳过某些步骤： package.json { \"standard-version\": { \"skip\": { \"changelog\": true } } } 版本管理与发布 git tag 语义化版本三段式：主版本（major）.次版本（minor）.修订版（patch），如 v1.2.1 修改主版本：架构升级或架构重大调整，不兼容的 API 修改 修改次版本：新功能上线或者模块大的调整，向下兼容的功能性新增 修改修订版：bug 修复上线，向下兼容的问题修正 其他定义，比如：1.2.0-beta.1，1.0.1-alpha.1，3.0.0-rc.1 内部测试版 alpha：一般不向外部发布,会有很多 Bug.一般只有测试人员使用 测试版 beta：这个阶段的版本会一直加入新的功能，在 alpha 版之后推出 最终测试版本 rc(Release Candidate)：可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本 git tag version // 打 tag git tag -a -m // 打详细的 tag git push origin v1.5 // 推送某一tag git push origin --tags // 推送本地所有 tag git tag -d v1.1.1 // 删除本地 tag npm tag npm 的 tag 有这几种类型： latest：最后版本，npm install 的就是这个 beta：测试版本，一般内测使用，需要指定版本号 install，例如 3.1.0-beta.0 next: 先行版本，npm install foo@next 安装，例如 3.0.2-alpha.0 npm dist-tag ls [] // 查看包的tag npm publish --tag beta // 发布测试版本包 npm dist-tag add my-package@1.0.1-beta.0 beta // 修改已发布的包类型为测试 npm dist-tag add my-package@1.0.0 latest // 修改已发布的包类型为最后版本 npm publish npm 注册账号 npm 设置源为：www.npmjs.com/ 终端 npm login package.json 配置 versions,files,main,private,keywords....，其中 versions 每次发布都得更新；files 写需要打包的文件，优先级高于 .npmignore 和 .gitignore，支持通配符； npm publish 查看 npm 打包内容： npm publish --dry-run npm pack 设置要发布的地址： \"publishConfig\": { \"registry\": \"http://registry.npm.xxx.com/\" } 其他参考 git commit 、CHANGELOG 和版本发布的标准自动化 Copyright © Hazel Wei all rights reserved, powered by Gitbook            该文章修订时间： 2025-06-30 23:42:45 "}}